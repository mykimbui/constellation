<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Night Sky Constellation Map</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #080E1C;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            color: white;
        }

        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 20px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        .controls h1 {
            font-size: 16px;
            font-weight: normal;
            margin-bottom: 20px;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: #fff;
            text-align: center;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
            color: #ccc;
        }

        .slider {
            width: 100%;
            height: 2px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            border-radius: 1px;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .value {
            font-size: 9px;
            color: #999;
            margin-top: 3px;
        }

        .button {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            font-family: inherit;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            margin-top: 5px;
            transition: all 0.3s ease;
        }

        .button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .textarea {
            width: 100%;
            height: 60px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            color: white;
            font-family: inherit;
            font-size: 9px;
            resize: vertical;
        }

        .textarea::placeholder {
            color: #999;
        }

        .file-input {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            color: white;
            font-family: inherit;
            font-size: 10px;
        }

        .info {
            font-size: 9px;
            color: #999;
            margin-top: 8px;
            text-align: center;
        }

        .instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 4px;
            font-size: 10px;
            color: #ccc;
            max-width: 300px;
        }

        #threejs-container {
            width: 100%;
            height: 100%;
        }

        .svg-section {
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            padding-top: 15px;
            margin-top: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="threejs-container"></div>
        
        <div class="controls">
            <h1>Night Sky</h1>
            
            <div class="control-group">
                <label for="constellationSize">Constellation Size</label>
                <input type="range" id="constellationSize" class="slider" min="0.5" max="1" value="1.5" step="0.1">
                <div class="value" id="constellationSizeValue">1.5</div>
            </div>



            <div class="control-group">
                <label for="animationSpeed">Animation Speed</label>
                <input type="range" id="animationSpeed" class="slider" min="0" max="2" value="0.5" step="0.1">
                <div class="value" id="animationSpeedValue">0.5</div>
            </div>


            <div class="control-group">
                <label for="outlineOpacity">Outline Opacity</label>
                <input type="range" id="outlineOpacity" class="slider" min="0.7" max="1" value="0.6=7" step="0.05">
                <div class="value" id="outlineOpacityValue">0.6</div>
            </div>

            <div class="control-group">
                <label for="lineThickness">Line Thickness</label>
                <input type="range" id="lineThickness" class="slider" min="0.02" max="1" value="0.06" step="0.01">
                <div class="value" id="lineThicknessValue">0.05</div>
            </div>

            <div class="control-group">
                <label for="bloomIntensity">Bloom Intensity</label>
                <input type="range" id="bloomIntensity" class="slider" min="0" max="3" value="1" step="0.1">
                <div class="value" id="bloomIntensityValue">1</div>
            </div>

            <div class="control-group">
                <label for="bloomRadius">Bloom Radius</label>
                <input type="range" id="bloomRadius" class="slider" min="0" max="1" value="0.5" step="0.01">
                <div class="value" id="bloomRadiusValue">0.5</div>
            </div>

            <div class="control-group">
                <label for="bloomThreshold">Bloom Threshold</label>
                <input type="range" id="bloomThreshold" class="slider" min="0" max="1" value="0.3" step="0.01">
                <div class="value" id="bloomThresholdValue">0.3</div>
            </div>

            <div class="control-group">
                <label for="backgroundOpacity">Background Stars</label>
                <input type="range" id="backgroundOpacity" class="slider" min="0" max="1" value="1" step="0.1">
                <div class="value" id="backgroundOpacityValue">1</div>
            </div>



            <div class="control-group">
                <button class="button" onclick="toggleShape()">Switch Constellation</button>
            </div>

            <div class="svg-section">
                <div class="control-group">
                    <label for="svgFile">Upload SVG</label>
                    <input type="file" id="svgFile" class="file-input" accept=".svg">
                </div>

                <div class="control-group">
                    <label for="svgText">Paste SVG Code</label>
                    <textarea id="svgText" class="textarea" placeholder="Paste SVG code..."></textarea>
                    <button class="button" onclick="loadSVGFromText()">Load SVG</button>
                </div>

                <button class="button" onclick="resetToDefault()">Reset Default</button>
                
                <div class="info" id="pointInfo">Stars: 0</div>
            </div>
        </div>

        <div class="instructions">
            <strong>Controls:</strong><br>
            • Mouse/Touch: Look around<br>
            • Scroll: Zoom in/out<br>
            • Upload SVG to create custom constellations
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script>
        let nightSkyInstance = null;

        class NightSkyConstellations {
            constructor() {
                this.container = document.getElementById('threejs-container');
                
                // Scene setup
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x080E1C);
                this.container.appendChild(this.renderer.domElement);

                // Camera controls
                this.setupCameraControls();

                // Parameters
                this.constellationSize = 1.5;
                this.animationSpeed = 0.5;
                this.pathDensity = 50;
                this.outlineOpacity = 0.6;
                this.lineThickness = 0.05;
                this.bloomIntensity = 1;
                this.bloomRadius = 0.5;
                this.bloomThreshold = 0.3;
                this.backgroundOpacity = 1;

                // Animation
                this.animationOffset = 0;
                this.mouse = { x: 0, y: 0 };
                this.targetRotation = { x: 0, y: 0 };
                this.currentRotation = { x: 0, y: 0 };

                // Constellation data
                this.constellationOutlines = [];
                this.constellationStars = [];
                this.constellationOutlines2 = [];
                this.constellationStars2 = [];
                this.svgPaths = [];
                this.svgBounds = null;
                this.svgPaths2 = [];
                this.svgBounds2 = null;
                this.currentShape = 0;
                this.isMorphing = false;

                // Groups
                this.constellationGroup = new THREE.Group();
                this.constellationGroup2 = new THREE.Group();
                this.backgroundGroup = new THREE.Group();
                this.scene.add(this.constellationGroup);
                this.scene.add(this.constellationGroup2);
                this.scene.add(this.backgroundGroup);

                // Post-processing setup
                this.setupPostProcessing();

                // Default SVGs
                this.defaultSVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 58 58">
                    <path fill="#333" d="M56.3,17.9c-4.3,1.1-9.1,2.4-12.1,3.2-.8.2-1.4-.8-.8-1.4l14.1-14.1c.2-.2.4-.6.4-.9,0-2.6-2.1-4.6-4.6-4.6s-.7.1-.9.4l-14.1,14.1c-.6.6-1.6,0-1.4-.8l3.2-12.1c.2-.8-.4-1.6-1.2-1.6h-5c-.6,0-1.1.4-1.2.9l-2.5,9.3c-.2.6-.2,1.2,0,1.7l1.8,6.7c1,3.5,3.7,6.3,7.3,7.3l6.7,1.8c.6.2,1.2.2,1.7,0l9.3-2.5c.5,0,.9-.6.9-1.2v-5c0-.8-.8-1.4-1.6-1.2Z"/>
                    <path fill="#333" d="M57,32.7l-9.3-2.5c-.5-.2-1.1-.2-1.7,0l-6.7,1.8c-3.6,1-6.3,3.8-7.3,7.3l-1.8,6.7c-.2.5-.2,1.1,0,1.7l2.5,9.3c0,.5.6.9,1.2.9h5c.8,0,1.4-.8,1.2-1.6l-3.2-12.1c-.2-.8.8-1.4,1.4-.8l14.1,14.1c.2.3.6.4.9.4,2.5,0,4.6-2,4.6-4.6s-.2-.7-.4-.9l-14.1-14.1c-.6-.6,0-1.6.8-1.4,3,.8,7.8,2.1,12.1,3.2.8.2,1.6-.4,1.6-1.2v-5c0-.6-.4-1.1-.9-1.2Z"/>
                    <path fill="#333" d="M.9,25.3l9.3,2.5c.5.2,1.1.2,1.7,0l6.7-1.8c3.6-1,6.3-3.8,7.3-7.3l1.8-6.7c.2-.5.2-1.1,0-1.7l-2.5-9.3h0c0-.5-.6-.9-1.2-.9h-5c-.8,0-1.4.8-1.2,1.6l3.2,12.1c.2.8-.8,1.4-1.4.8L5.6.5c-.2-.3-.6-.4-.9-.4C2.2,0,0,2.2,0,4.7s.2.7.4.9l14.1,14.1c.6.6,0,1.6-.8,1.4-3-.8-7.8-2.1-12.1-3.2-.8-.2-1.6.4-1.6,1.2v5c0,.6.3,1.1.9,1.2Z"/>
                    <path fill="#333" d="M26,39.3c-1-3.5-3.7-6.3-7.3-7.3l-6.7-1.8c-.6-.2-1.2-.2-1.7,0l-9.3,2.5c-.6,0-.9.6-.9,1.2v5c0,.8.8,1.4,1.6,1.2,4.3-1.1,9.1-2.4,12.1-3.2.8-.2,1.4.8.8,1.4L.5,52.4c-.2.2-.4.6-.4.9,0,2.6,2.1,4.6,4.6,4.6s.7-.1.9-.4l14.1-14.1c.6-.6,1.6,0,1.4.8l-3.2,12.1c-.2.8.4,1.6,1.2,1.6h5c.6,0,1.1-.4,1.2-.9l2.5-9.3c.2-.6.2-1.2,0-1.7l-1.8-6.7Z"/>
                </svg>`;

                this.geometricSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="83" height="58" viewBox="0 0 83 58" fill="none">
  <path d="M21.7305 8.9599e-06C24.2113 -0.00260739 26.6591 0.567805 28.8816 1.66649C31.1041 2.76517 33.041 4.36222 34.5402 6.33234L34.7915 6.05853C37.4485 3.42782 41.0707 1.81091 45.0588 1.81091C50.5494 1.81091 55.3065 4.8555 57.8685 9.39067C60.1423 8.376 62.6057 7.852 65.097 7.85305C74.9787 7.85305 83 15.9207 83 25.8748C83 35.8295 74.9787 43.896 65.097 43.896C63.8894 43.896 62.712 43.7745 61.5591 43.5461C59.3174 47.5337 55.0323 50.2432 50.1521 50.2432C48.1653 50.2469 46.204 49.7971 44.4187 48.9281C42.1462 54.2556 36.8551 57.9995 30.6942 58C24.2586 58 18.7998 53.9506 16.6949 48.2584C15.7582 48.4557 14.8034 48.5549 13.846 48.5544C6.19112 48.5549 0 42.2834 0 34.582C0 29.4073 2.78744 24.9012 6.92352 22.466C6.04601 20.4484 5.59435 18.2725 5.59662 16.0734C5.59662 7.18493 12.8251 8.9599e-06 21.7305 8.9599e-06Z" fill="white"/>
</svg>`;

                this.init();
            }

            loadBothSVGs() {
                // Load first SVG (default)
                this.loadSVG(this.defaultSVG, 1);
                // Load second SVG (geometric)
                this.loadSVG(this.geometricSVG, 2);
            }

            setupPostProcessing() {
                const renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
                    minFilter: THREE.LinearFilter,
                    magFilter: THREE.LinearFilter,
                    format: THREE.RGBAFormat,
                    encoding: THREE.sRGBEncoding
                });

                this.composer = new THREE.EffectComposer(this.renderer, renderTarget);
                
                // Render pass
                const renderPass = new THREE.RenderPass(this.scene, this.camera);
                this.composer.addPass(renderPass);

                // Bloom pass
                this.bloomPass = new THREE.UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    this.bloomIntensity,
                    this.bloomRadius,
                    this.bloomThreshold
                );
                this.composer.addPass(this.bloomPass);

                // Copy pass to screen
                const copyPass = new THREE.ShaderPass(THREE.CopyShader);
                copyPass.renderToScreen = true;
                this.composer.addPass(copyPass);
            }



            init() {
                this.setupControls();
                this.setupFileInput();
                this.createBackgroundStarfield();
                this.loadBothSVGs();
                this.setupCamera();
                this.animate();
                this.handleResize();
            }

            setupCameraControls() {
                this.container.addEventListener('mousemove', (event) => {
                    this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                });

                this.container.addEventListener('wheel', (event) => {
                    event.preventDefault();
                    const zoomSpeed = 0.1;
                    this.camera.fov += event.deltaY * zoomSpeed;
                    this.camera.fov = Math.max(10, Math.min(120, this.camera.fov));
                    this.camera.updateProjectionMatrix();
                });

                // Touch controls for mobile
                let touchStartX = 0, touchStartY = 0;
                this.container.addEventListener('touchstart', (event) => {
                    touchStartX = event.touches[0].clientX;
                    touchStartY = event.touches[0].clientY;
                });

                this.container.addEventListener('touchmove', (event) => {
                    event.preventDefault();
                    const touchX = event.touches[0].clientX;
                    const touchY = event.touches[0].clientY;
                    this.mouse.x = (touchX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(touchY / window.innerHeight) * 2 + 1;
                });
            }

            setupControls() {
                const controls = ['constellationSize', 'animationSpeed', 'pathDensity', 'outlineOpacity', 'lineThickness', 'bloomIntensity', 'bloomRadius', 'bloomThreshold', 'backgroundOpacity'];
                
                controls.forEach(controlName => {
                    const element = document.getElementById(controlName);
                    const valueElement = document.getElementById(controlName + 'Value');
                    
                    if (element && valueElement) {
                        element.addEventListener('input', (e) => {
                            const value = parseFloat(e.target.value);
                            this[controlName] = value;
                            valueElement.textContent = value;
                            
                            if (controlName === 'pathDensity') {
                                this.extractPointsFromPaths(1);
                                this.extractPointsFromPaths(2);
                            } else if (controlName === 'constellationSize') {
                                this.updateConstellationScale();
                            } else if (controlName === 'outlineOpacity') {
                                this.updateOutlineMaterials();
                            } else if (controlName === 'lineThickness') {
                                this.extractPointsFromPaths(1); // Recreate with new thickness
                                this.extractPointsFromPaths(2);
                            } else if (controlName === 'bloomIntensity' || controlName === 'bloomRadius' || controlName === 'bloomThreshold') {
                                this.updateBloomSettings();
                            } else if (controlName === 'backgroundOpacity') {
                                this.updateBackgroundOpacity();
                            }
                        });
                        
                        valueElement.textContent = element.value;
                    }
                });
            }

            setupFileInput() {
                const fileInput = document.getElementById('svgFile');
                if (fileInput) {
                    fileInput.addEventListener('change', (e) => {
                        const file = e.target.files[0];
                        if (file && file.type === 'image/svg+xml') {
                            const reader = new FileReader();
                            reader.onload = (e) => {
                                // Load the uploaded SVG as the first constellation
                                this.loadSVG(e.target.result, 1);
                                // Keep the second constellation as is
                            };
                            reader.readAsText(file);
                        }
                    });
                }
            }

            createBackgroundStarfield() {
                const starCount = 1500;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(starCount * 3);
                const sizes = new Float32Array(starCount);
                const colors = new Float32Array(starCount * 3);

                for (let i = 0; i < starCount * 3; i += 3) {
                    // Create stars in a sphere around the viewer - much closer and more visible
                    const radius = 150 + Math.random() * 300;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);

                    positions[i] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i + 2] = radius * Math.cos(phi);

                    sizes[i / 3] = 2.0 + Math.random() * 6.0; // Much larger stars

                    // Brighter star colors
                    const colorChoice = Math.random();
                    if (colorChoice < 0.6) {
                        // Bright white stars (60%)
                        colors[i] = 1.0;
                        colors[i + 1] = 1.0;
                        colors[i + 2] = 1.0;
                    } else if (colorChoice < 0.8) {
                        // Bright blue stars (20%)
                        colors[i] = 0.8;
                        colors[i + 1] = 0.9;
                        colors[i + 2] = 1.0;
                    } else if (colorChoice < 0.95) {
                        // Bright yellow stars (15%)
                        colors[i] = 1.0;
                        colors[i + 1] = 1.0;
                        colors[i + 2] = 0.9;
                    } else {
                        // Bright red stars (5%)
                        colors[i] = 1.0;
                        colors[i + 1] = 0.8;
                        colors[i + 2] = 0.8;
                    }
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        opacity: { value: 1.0 } // Full opacity
                    },
                    vertexShader: `
                        attribute float size;
                        attribute vec3 color;
                        uniform float time;
                        varying float vAlpha;
                        varying vec3 vColor;
                        
                        void main() {
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            
                            // Create slower, more subtle twinkling effect
                            float twinkle = sin(time * 0.5 + position.x * 0.01 + position.y * 0.015) * 0.3 + 0.7;
                            twinkle *= sin(time * 0.3 + position.z * 0.01) * 0.2 + 0.8;
                            vAlpha = twinkle;
                            vColor = color;
                            
                            gl_PointSize = size * (500.0 / -mvPosition.z) * twinkle; // Much larger point size
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        uniform float opacity;
                        varying float vAlpha;
                        varying vec3 vColor;
                        
                        void main() {
                            vec2 center = vec2(0.5, 0.5);
                            float dist = distance(gl_PointCoord, center);
                            
                            if (dist > 0.5) discard;
                            
                            float alpha = 1.0 - (dist * 2.0);
                            alpha = alpha * alpha * vAlpha * opacity;
                            
                            // Make stars brighter
                            vec3 brightColor = vColor * 1.5;
                            gl_FragColor = vec4(brightColor, alpha);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });

                const stars = new THREE.Points(geometry, material);
                this.backgroundGroup.add(stars);
                this.backgroundStarMaterial = material;
            }

            loadSVG(svgString, constellationNumber = 1) {
                try {
                    const parser = new DOMParser();
                    const svgDoc = parser.parseFromString(svgString, 'image/svg+xml');
                    const svgElement = svgDoc.querySelector('svg');
                    
                    if (svgElement) {
                        const viewBox = svgElement.getAttribute('viewBox');
                        if (viewBox) {
                            const [x, y, width, height] = viewBox.split(' ').map(Number);
                            if (constellationNumber === 1) {
                                this.svgBounds = { x, y, width, height };
                            } else {
                                this.svgBounds2 = { x, y, width, height };
                            }
                        } else {
                            if (constellationNumber === 1) {
                                this.svgBounds = { x: 0, y: 0, width: 100, height: 100 };
                            } else {
                                this.svgBounds2 = { x: 0, y: 0, width: 100, height: 100 };
                            }
                        }
                        
                        const paths = Array.from(svgElement.querySelectorAll('path')).map(path => ({
                            d: path.getAttribute('d')
                        }));
                        
                        if (constellationNumber === 1) {
                            this.svgPaths = paths;
                        } else {
                            this.svgPaths2 = paths;
                        }
                        
                        this.extractPointsFromPaths(constellationNumber);
                    }
                } catch (error) {
                    console.error('Error loading SVG:', error);
                }
            }

            extractPointsFromPaths(constellationNumber = 1) {
                const group = constellationNumber === 1 ? this.constellationGroup : this.constellationGroup2;
                const outlines = constellationNumber === 1 ? this.constellationOutlines : this.constellationOutlines2;
                const stars = constellationNumber === 1 ? this.constellationStars : this.constellationStars2;
                const paths = constellationNumber === 1 ? this.svgPaths : this.svgPaths2;
                const bounds = constellationNumber === 1 ? this.svgBounds : this.svgBounds2;

                // Clear existing constellation outlines and stars
                outlines.forEach(outline => {
                    group.remove(outline);
                });
                if (constellationNumber === 1) {
                    this.constellationOutlines = [];
                } else {
                    this.constellationOutlines2 = [];
                }

                stars.forEach(star => {
                    group.remove(star);
                });
                if (constellationNumber === 1) {
                    this.constellationStars = [];
                } else {
                    this.constellationStars2 = [];
                }

                if (!paths.length || !bounds) return;

                const scale = 4; // Scale for 3D space
                const offsetX = constellationNumber === 1 ? -15 : 15; // Position constellations side by side
                const offsetY = constellationNumber === 1 ? 10 : -10; // Position first constellation higher (top left)

                // Create constellation outlines
                paths.forEach(pathData => {
                    if (pathData.d) {
                        const outline = this.createConstellationOutline(pathData.d, scale, bounds, offsetX, offsetY);
                        if (outline) {
                            if (constellationNumber === 1) {
                                this.constellationOutlines.push(outline);
                            } else {
                                this.constellationOutlines2.push(outline);
                            }
                            group.add(outline);
                        }
                    }
                });

                // Create random stars along the paths
                paths.forEach(pathData => {
                    if (pathData.d) {
                        const starPoints = this.generateRandomStarPoints(pathData.d, scale, bounds, offsetX, offsetY);
                        starPoints.forEach(point => {
                            const star = this.createConstellationStar(point);
                            if (constellationNumber === 1) {
                                this.constellationStars.push(star);
                            } else {
                                this.constellationStars2.push(star);
                            }
                            group.add(star);
                        });
                    }
                });

                this.updatePointInfo();
            }





            updateConstellationScale() {
                this.constellationGroup.scale.setScalar(this.constellationSize);
                this.constellationGroup2.scale.setScalar(this.constellationSize);
            }

            generateRandomStarPoints(pathString, scale, bounds, offsetX = 0, offsetY = 0) {
                const points = [];
                
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '1000');
                svg.setAttribute('height', '1000');
                svg.setAttribute('viewBox', `${bounds.x} ${bounds.y} ${bounds.width} ${bounds.height}`);
                
                const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                pathElement.setAttribute('d', pathString);
                pathElement.setAttribute('stroke', 'black');
                pathElement.setAttribute('stroke-width', '1');
                pathElement.setAttribute('fill', 'none');
                
                svg.appendChild(pathElement);
                document.body.appendChild(svg);
                
                try {
                    const totalLength = pathElement.getTotalLength();
                    const numStars = Math.max(3, Math.min(15, Math.floor(totalLength / 20))); // Random number of stars based on path length
                    
                    for (let i = 0; i < numStars; i++) {
                        const randomDistance = Math.random() * totalLength;
                        const point = pathElement.getPointAtLength(randomDistance);
                        
                        if (point) {
                            // Convert 2D SVG coordinates to 3D positions
                            const x = (point.x - bounds.x - bounds.width / 2) * scale / 10 + offsetX;
                            const y = -(point.y - bounds.y - bounds.height / 2) * scale / 10 + offsetY;
                            const z = (Math.random() - 0.5) * 2; // Small depth variation
                            
                            points.push({ 
                                x, 
                                y, 
                                z, 
                                twinklePhase: Math.random() * Math.PI * 2,
                                size: 0.5 + Math.random() * 1.5 // Random star size
                            });
                        }
                    }
                } catch (error) {
                    console.warn('Could not generate star points:', error);
                } finally {
                    document.body.removeChild(svg);
                }

                return points;
            }

            createConstellationStar(point) {
                const geometry = new THREE.SphereGeometry(point.size * 0.1, 8, 8);
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        twinklePhase: { value: point.twinklePhase }
                    },
                    vertexShader: `
                        varying vec3 vPosition;
                        varying vec3 vNormal;
                        
                        void main() {
                            vPosition = position;
                            vNormal = normal;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform float twinklePhase;
                        varying vec3 vPosition;
                        varying vec3 vNormal;
                        
                        void main() {
                            float twinkle = sin(time * 2.0 + twinklePhase) * 0.3 + 0.7;
                            float intensity = twinkle;
                            
                            // Create bright emission for bloom effect
                            vec3 color = vec3(1.0, 1.0, 1.0) * intensity * 2.0;
                            gl_FragColor = vec4(color, 1.0);
                        }
                    `,
                    transparent: false
                });

                const star = new THREE.Mesh(geometry, material);
                star.position.set(point.x, point.y, point.z);

                return star;
            }

            createConstellationOutline(pathString, scale, bounds, offsetX = 0, offsetY = 0) {
                const points = [];
                
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '1000');
                svg.setAttribute('height', '1000');
                svg.setAttribute('viewBox', `${bounds.x} ${bounds.y} ${bounds.width} ${bounds.height}`);
                
                const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                pathElement.setAttribute('d', pathString);
                pathElement.setAttribute('stroke', 'black');
                pathElement.setAttribute('stroke-width', '1');
                pathElement.setAttribute('fill', 'none');
                
                svg.appendChild(pathElement);
                document.body.appendChild(svg);
                
                try {
                    const totalLength = pathElement.getTotalLength();
                    const segments = Math.max(100, Math.floor(totalLength / 0.2)); // Even more segments for ultra-smooth curves

                    for (let i = 0; i < segments; i++) {
                        const distance = (i / Math.max(1, segments - 1)) * totalLength;
                        const point = pathElement.getPointAtLength(distance);
                        
                        if (point) {
                            // Convert 2D SVG coordinates to 3D positions
                            const x = (point.x - bounds.x - bounds.width / 2) * scale / 10 + offsetX;
                            const y = -(point.y - bounds.y - bounds.height / 2) * scale / 10 + offsetY;
                            const z = 0; // Keep outline flat
                            
                            points.push(new THREE.Vector3(x, y, z));
                        }
                    }
                } catch (error) {
                    console.warn('Could not create outline:', error);
                    return null;
                } finally {
                    document.body.removeChild(svg);
                }

                if (points.length < 2) return null;

                // Create curve from points
                const curve = new THREE.CatmullRomCurve3(points);
                
                // Create tube geometry for thick lines
                const tubeSegments = Math.max(400, points.length * 8); // Ultra-smooth tube segments
                const radius = this.lineThickness;
                const radialSegments = 16; // Ultra-smooth radial segments
                const closed = false;
                
                const geometry = new THREE.TubeGeometry(curve, tubeSegments, radius, radialSegments, closed);

                // Create glowing tube material
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        opacity: { value: this.outlineOpacity },
                        dashSize: { value: 5.0 },
                        gapSize: { value: 0.9 }
                    },
                    vertexShader: `
                        uniform float time;
                        varying vec3 vPosition;
                        varying vec3 vNormal;
                        varying vec2 vUv;
                        
                        void main() {
                            vPosition = position;
                            vNormal = normalize(normalMatrix * normal);
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform float opacity;
                        uniform float dashSize;
                        uniform float gapSize;
                        varying vec3 vPosition;
                        varying vec3 vNormal;
                        varying vec2 vUv;
                        
                        void main() {
                            // Create animated dashed effect along the tube
                            float totalSize = dashSize + gapSize;
                            float animatedOffset = time * 0.3;
                            float pattern = mod(vUv.x * 20.0 + animatedOffset, totalSize);
                            float dashAlpha = smoothstep(gapSize - 0.2, gapSize, pattern) * 
                                            (1.0 - smoothstep(dashSize, dashSize + 0.2, pattern));
                            
                            // Add fresnel glow effect
                            vec3 viewDirection = normalize(cameraPosition - vPosition);
                            float fresnel = 1.0 - abs(dot(vNormal, viewDirection));
                            fresnel = pow(fresnel, 2.0);
                            
                            // Combine effects
                            float finalAlpha = dashAlpha * opacity * (0.4 + fresnel * 0.6);
                            
                            // Pure white glow
                            vec3 glowColor = vec3(1.0, 1.0, 1.0);
                            gl_FragColor = vec4(glowColor, finalAlpha);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide
                });

                const tube = new THREE.Mesh(geometry, material);
                return tube;
            }

            updateOutlineMaterials() {
                this.constellationOutlines.forEach(outline => {
                    if (outline.material && outline.material.uniforms) {
                        outline.material.uniforms.opacity.value = this.outlineOpacity;
                    }
                });
                this.constellationOutlines2.forEach(outline => {
                    if (outline.material && outline.material.uniforms) {
                        outline.material.uniforms.opacity.value = this.outlineOpacity;
                    }
                });
            }



            updatePointInfo() {
                const pointInfoElement = document.getElementById('pointInfo');
                if (pointInfoElement) {
                    const totalOutlines = this.constellationOutlines.length + this.constellationOutlines2.length;
                    const totalStars = this.constellationStars.length + this.constellationStars2.length;
                    pointInfoElement.textContent = `Outlines: ${totalOutlines} | Stars: ${totalStars}`;
                }
            }

            updateBloomSettings() {
                if (this.bloomPass) {
                    this.bloomPass.strength = this.bloomIntensity;
                    this.bloomPass.radius = this.bloomRadius;
                    this.bloomPass.threshold = this.bloomThreshold;
                }
            }

            updateBackgroundOpacity() {
                if (this.backgroundStarMaterial) {
                    this.backgroundStarMaterial.uniforms.opacity.value = this.backgroundOpacity;
                }
            }



            setupCamera() {
                this.camera.position.z = 30;
                this.camera.lookAt(0, 0, 0);
            }

            handleResize() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    
                    if (this.composer) {
                        this.composer.setSize(window.innerWidth, window.innerHeight);
                    }
                });
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                this.animationOffset += this.animationSpeed * 0.01;

                // Smooth camera movement based on mouse
                const dampening = 0.02;
                this.targetRotation.x = this.mouse.y * 0.3;
                this.targetRotation.y = this.mouse.x * 0.3;
                
                this.currentRotation.x += (this.targetRotation.x - this.currentRotation.x) * dampening;
                this.currentRotation.y += (this.targetRotation.y - this.currentRotation.y) * dampening;

                // Apply rotation to constellation groups
                this.constellationGroup.rotation.x = this.currentRotation.x;
                this.constellationGroup.rotation.y = this.currentRotation.y;
                this.constellationGroup2.rotation.x = this.currentRotation.x;
                this.constellationGroup2.rotation.y = this.currentRotation.y;

                // Gentle background rotation - much slower
                this.backgroundGroup.rotation.y += 0.0001;

                // Update shader uniforms
                if (this.backgroundStarMaterial) {
                    this.backgroundStarMaterial.uniforms.time.value = this.animationOffset * 10;
                }

                this.constellationOutlines.forEach(outline => {
                    if (outline.material && outline.material.uniforms) {
                        outline.material.uniforms.time.value = this.animationOffset * 10;
                    }
                });

                this.constellationOutlines2.forEach(outline => {
                    if (outline.material && outline.material.uniforms) {
                        outline.material.uniforms.time.value = this.animationOffset * 10;
                    }
                });

                this.constellationStars.forEach(star => {
                    if (star.material && star.material.uniforms) {
                        star.material.uniforms.time.value = this.animationOffset * 10;
                    }
                });

                this.constellationStars2.forEach(star => {
                    if (star.material && star.material.uniforms) {
                        star.material.uniforms.time.value = this.animationOffset * 10;
                    }
                });

                this.composer.render();
            }
        }

        function loadSVGFromText() {
            if (nightSkyInstance) {
                const svgTextElement = document.getElementById('svgText');
                if (svgTextElement) {
                    const svgText = svgTextElement.value.trim();
                    if (svgText) {
                        // Load the pasted SVG as the first constellation
                        nightSkyInstance.loadSVG(svgText, 1);
                        // Keep the second constellation as is
                    }
                }
            }
        }

        function resetToDefault() {
            if (nightSkyInstance) {
                nightSkyInstance.currentShape = 0;
                nightSkyInstance.loadBothSVGs();
                const svgTextElement = document.getElementById('svgText');
                const svgFileElement = document.getElementById('svgFile');
                if (svgTextElement) svgTextElement.value = '';
                if (svgFileElement) svgFileElement.value = '';
            }
        }

        function toggleShape() {
            if (nightSkyInstance) {
                // Reload both SVGs to refresh the side-by-side display
                nightSkyInstance.loadBothSVGs();
            }
        }

        // Initialize the night sky
        nightSkyInstance = new NightSkyConstellations();
    </script>
</body>
</html>