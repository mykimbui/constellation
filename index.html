<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Night Sky Constellation Map</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #080E1C;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            color: white;
        }

        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 20px;
            backdrop-filter: blur(10px);
            z-index: 100;
            display: none; /* Hide controls by default */
        }

        .controls h1 {
            font-size: 16px;
            font-weight: normal;
            margin-bottom: 20px;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: #fff;
            text-align: center;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
            color: #ccc;
        }

        .slider {
            width: 100%;
            height: 2px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            border-radius: 1px;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .value {
            font-size: 9px;
            color: #999;
            margin-top: 3px;
        }

        .button {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            font-family: inherit;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            margin-top: 5px;
            transition: all 0.3s ease;
        }

        .button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .textarea {
            width: 100%;
            height: 60px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            color: white;
            font-family: inherit;
            font-size: 9px;
            resize: vertical;
        }

        .textarea::placeholder {
            color: #999;
        }

        .file-input {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            color: white;
            font-family: inherit;
            font-size: 10px;
        }

        .info {
            font-size: 9px;
            color: #999;
            margin-top: 8px;
            text-align: center;
        }

        .instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 4px;
            font-size: 10px;
            color: #ccc;
            max-width: 300px;
        }

        .controls-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 101;
            transition: all 0.3s ease;
        }

        .controls-toggle:hover {
            background: rgba(0, 0, 0, 0.8);
            border-color: rgba(255, 255, 255, 0.5);
        }

        #threejs-container {
            width: 100%;
            height: 100%;
        }

        .svg-section {
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            padding-top: 15px;
            margin-top: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="threejs-container"></div>
        
        <button class="controls-toggle" onclick="toggleControls()">⚙️</button>
        
        <div class="controls">
            <h1>Night Sky</h1>
            
            <div class="control-group">
                <label for="constellationSize">Constellation Size</label>
                <input type="range" id="constellationSize" class="slider" min="0.1" max="1" value="0.5" step="0.1">
                <div class="value" id="constellationSizeValue">1.5</div>
            </div>



            <div class="control-group">
                <label for="animationSpeed">Animation Speed</label>
                <input type="range" id="animationSpeed" class="slider" min="0" max="2" value="0.5" step="0.1">
                <div class="value" id="animationSpeedValue">0.5</div>
            </div>


            <div class="control-group">
                <label for="outlineOpacity">Outline Opacity</label>
                <input type="range" id="outlineOpacity" class="slider" min="0.7" max="1" value="1" step="0.05">
                <div class="value" id="outlineOpacityValue">0.6</div>
            </div>

            <div class="control-group">
                <label for="lineThickness">Line Thickness</label>
                <input type="range" id="lineThickness" class="slider" min="0.02" max="1" value="0.9" step="0.01">
                <div class="value" id="lineThicknessValue">0.05</div>
            </div>

            <div class="control-group">
                <label for="bloomIntensity">Bloom Intensity</label>
                <input type="range" id="bloomIntensity" class="slider" min="0" max="3" value="1" step="0.1">
                <div class="value" id="bloomIntensityValue">1</div>
            </div>

            <div class="control-group">
                <label for="bloomRadius">Bloom Radius</label>
                <input type="range" id="bloomRadius" class="slider" min="0" max="1" value="0.5" step="0.01">
                <div class="value" id="bloomRadiusValue">0.5</div>
            </div>

            <div class="control-group">
                <label for="bloomThreshold">Bloom Threshold</label>
                <input type="range" id="bloomThreshold" class="slider" min="0" max="1" value="0.3" step="0.01">
                <div class="value" id="bloomThresholdValue">0.3</div>
            </div>

            <div class="control-group">
                <label for="backgroundOpacity">Background Stars</label>
                <input type="range" id="backgroundOpacity" class="slider" min="0" max="1" value="1" step="0.1">
                <div class="value" id="backgroundOpacityValue">1</div>
            </div>



            <div class="control-group">
                <button class="button" onclick="toggleShape()">Switch Constellation</button>
            </div>

            <div class="svg-section">
                <div class="control-group">
                    <label for="svgFile">Upload SVG</label>
                    <input type="file" id="svgFile" class="file-input" accept=".svg">
                </div>

                <div class="control-group">
                    <label for="svgText">Paste SVG Code</label>
                    <textarea id="svgText" class="textarea" placeholder="Paste SVG code..."></textarea>
                    <button class="button" onclick="loadSVGFromText()">Load SVG</button>
                </div>

                <button class="button" onclick="resetToDefault()">Reset Default</button>
                
                <div class="info" id="pointInfo">Stars: 0</div>
            </div>
        </div>

        <div class="instructions">
            <strong>Controls:</strong><br>
            • Mouse/Touch: Look around<br>
            • Scroll: Zoom in/out<br>
            • Upload SVG to create custom constellations
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script>
        let nightSkyInstance = null;

        class NightSkyConstellations {
            constructor() {
                this.container = document.getElementById('threejs-container');
                
                // Scene setup
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x080E1C);
                this.container.appendChild(this.renderer.domElement);

                // Camera controls
                this.setupCameraControls();

                // Parameters
                this.constellationSize = 1.5;
                this.animationSpeed = 0.5;
                this.pathDensity = 50;
                this.outlineOpacity = 0.6;
                this.lineThickness = 0.05;
                this.bloomIntensity = 1;
                this.bloomRadius = 0.5;
                this.bloomThreshold = 0.3;
                this.backgroundOpacity = 1;

                // Animation
                this.animationOffset = 0;
                this.mouse = { x: 0, y: 0 };
                this.targetRotation = { x: 0, y: 0 };
                this.currentRotation = { x: 0, y: 0 };

                // Constellation data
                this.constellationOutlines = [];
                this.constellationStars = [];
                this.svgPaths = [];
                this.svgBounds = null;
                this.constellationOutlines2 = [];
                this.constellationStars2 = [];
                this.svgPaths2 = [];
                this.svgBounds2 = null;
                this.currentShape = 0;
                this.isMorphing = false;

                // Groups
                this.constellationGroup = new THREE.Group();
                this.constellationGroup2 = new THREE.Group();
                this.backgroundGroup = new THREE.Group();
                this.scene.add(this.constellationGroup);
                this.scene.add(this.constellationGroup2);
                this.scene.add(this.backgroundGroup);

                // Post-processing setup
                this.setupPostProcessing();

                // Default SVGs
                this.defaultSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="58" height="58" viewBox="0 0 58 58" fill="none">
  <path d="M19.0195 0.579834H23.9883C24.3268 0.580029 24.624 0.806722 24.7139 1.13354V1.13452L27.2051 10.4158V10.4167C27.3166 10.837 27.3307 11.2759 27.2471 11.7009L27.2051 11.8826L25.418 18.5437C24.5406 21.8097 22.039 24.3831 18.8154 25.3601L18.501 25.45L11.8281 27.2351C11.347 27.3622 10.8415 27.3624 10.3604 27.2351H10.3613L1.06445 24.7478L1.05859 24.7458L0.939453 24.7048C0.674993 24.5874 0.501953 24.325 0.501953 24.0281V19.0642C0.502161 18.6046 0.912605 18.2608 1.35352 18.324L1.44238 18.3416C5.70009 19.4826 10.5334 20.7755 13.5684 21.5867H13.5693C14.8827 21.9361 15.8256 20.3231 14.8545 19.3562H14.8535L0.719727 5.24585C0.578074 5.10108 0.500025 4.91134 0.5 4.71558C0.5 2.43324 2.35501 0.579834 4.64453 0.579834C4.84199 0.579898 5.03572 0.659811 5.17773 0.800537L19.3105 14.9119C20.2724 15.8722 21.8965 14.9451 21.541 13.6238L18.2939 1.52026V1.51929C18.1673 1.0489 18.5236 0.580108 19.0195 0.579834Z" stroke="#1A1A1A" stroke-miterlimit="10"/>
  <path d="M38.7817 0.5H33.813C33.4744 0.500195 33.1772 0.726888 33.0874 1.05371V1.05469L30.5962 10.3359V10.3369C30.4847 10.7572 30.4706 11.1961 30.5542 11.6211L30.5962 11.8027L32.3833 18.4639C33.2607 21.7298 35.7623 24.3033 38.9858 25.2803L39.3003 25.3701L45.9731 27.1553C46.4543 27.2824 46.9598 27.2826 47.4409 27.1553H47.4399L56.7368 24.668L56.7427 24.666L56.8618 24.625C57.1263 24.5076 57.2993 24.2451 57.2993 23.9482V18.9844C57.2991 18.5248 56.8887 18.181 56.4478 18.2441L56.3589 18.2617C52.1012 19.4028 47.2678 20.6957 44.2329 21.5068H44.2319C42.9186 21.8563 41.9757 20.2433 42.9468 19.2764H42.9478L57.0815 5.16602C57.2232 5.02125 57.3012 4.83151 57.3013 4.63574C57.3013 2.35341 55.4463 0.5 53.1567 0.5C52.9593 0.500065 52.7655 0.579977 52.6235 0.720703L38.4907 14.832C37.5289 15.7924 35.9048 14.8653 36.2603 13.5439L39.5073 1.44043V1.43945C39.6339 0.969069 39.2777 0.500274 38.7817 0.5Z" stroke="#1A1A1A" stroke-miterlimit="10"/>
  <path d="M38.7817 57.251H33.813C33.4744 57.2508 33.1772 57.0241 33.0874 56.6973V56.6963L30.5962 47.415V47.4141C30.4847 46.9938 30.4706 46.5549 30.5542 46.1299L30.5962 45.9482L32.3833 39.2871C33.2607 36.0212 35.7623 33.4477 38.9858 32.4707L39.3003 32.3809L45.9731 30.5957C46.4543 30.4686 46.9598 30.4684 47.4409 30.5957H47.4399L56.7368 33.083L56.7427 33.085L56.8618 33.126C57.1263 33.2434 57.2993 33.5058 57.2993 33.8027V38.7666C57.2991 39.2262 56.8887 39.57 56.4478 39.5068L56.3589 39.4893C52.1012 38.3482 47.2678 37.0553 44.2329 36.2441H44.2319C42.9186 35.8947 41.9757 37.5077 42.9468 38.4746H42.9478L57.0815 52.585C57.2232 52.7297 57.3012 52.9195 57.3013 53.1152C57.3013 55.3976 55.4463 57.251 53.1567 57.251C52.9593 57.2509 52.7655 57.171 52.6235 57.0303L38.4907 42.9189C37.5289 41.9586 35.9048 42.8857 36.2603 44.207L39.5073 56.3105V56.3115C39.6339 56.7819 39.2777 57.2507 38.7817 57.251Z" stroke="#1A1A1A" stroke-miterlimit="10"/>
  <path d="M19.0195 57.251H23.9883C24.3268 57.2508 24.624 57.0241 24.7139 56.6973V56.6963L27.2051 47.415V47.4141C27.3166 46.9938 27.3307 46.5549 27.2471 46.1299L27.2051 45.9482L25.418 39.2871C24.5406 36.0212 22.039 33.4477 18.8154 32.4707L18.501 32.3809L11.8281 30.5957C11.347 30.4686 10.8415 30.4684 10.3604 30.5957H10.3613L1.06445 33.083L1.05859 33.085L0.939453 33.126C0.674993 33.2434 0.501953 33.5058 0.501953 33.8027V38.7666C0.502161 39.2262 0.912605 39.57 1.35352 39.5068L1.44238 39.4893C5.70009 38.3482 10.5334 37.0553 13.5684 36.2441H13.5693C14.8827 35.8947 15.8256 37.5077 14.8545 38.4746H14.8535L0.719727 52.585C0.578074 52.7297 0.500025 52.9195 0.5 53.1152C0.5 55.3976 2.35501 57.251 4.64453 57.251C4.84199 57.2509 5.03572 57.171 5.17773 57.0303L19.3105 42.9189C20.2724 41.9586 21.8965 42.8857 21.541 44.207L18.2939 56.3105V56.3115C18.1673 56.7819 18.5236 57.2507 19.0195 57.251Z" stroke="#1A1A1A" stroke-miterlimit="10"/>
</svg>`;

                this.geometricSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="83" height="58" viewBox="0 0 83 58" fill="none">
  <g clip-path="url(#clip0_6290_28488)">
    <path d="M34.5395 6.32583C37.2164 3.54126 40.9431 1.81437 45.0646 1.81437C50.5436 1.81437 55.3237 4.86444 57.8695 9.39247C60.0816 8.40572 62.5305 7.85683 65.1064 7.85683C74.9884 7.85683 82.9999 15.9248 82.9999 25.8768C82.9999 35.8288 74.9884 43.8981 65.1064 43.8981C63.9229 43.8988 62.7419 43.7815 61.5819 43.5475C59.3403 47.5395 55.0684 50.2369 50.1654 50.2369C48.113 50.2369 46.1715 49.7636 44.4431 48.922C42.1706 54.2585 36.8761 58.0003 30.7056 58.0003C24.535 58.0003 18.8031 53.941 16.7008 48.2478C15.7822 48.4427 14.8304 48.5442 13.8536 48.5442C6.20267 48.5442 0.000244141 42.2882 0.000244141 34.5696C0.000244141 29.3972 2.78705 24.8808 6.92742 22.4645C6.07485 20.5062 5.60075 18.3448 5.60075 16.0727C5.60075 7.1959 12.8188 0.000305176 21.722 0.000305176C26.949 0.000305176 31.5944 2.48159 34.5399 6.32616" fill="#00A1E0"/>
    <path d="M12.0218 30.0774C15.057 33.4397 21.2192 28.3817 15.46 26.5547C11.6573 25.4884 15.0961 23.7121 16.9912 25.1424C17.2342 25.3827 17.6954 24.031 17.4796 23.9673C13.8707 21.2501 9.38042 26.7579 14.7296 27.8868C16.4368 28.087 16.9016 29.7377 15.0556 29.8766C12.9451 30.03 12.5142 27.9587 12.0215 30.0771L12.0218 30.0774Z" fill="white"/>
    <path d="M36.9466 30.0774C39.9818 33.4397 46.144 28.3817 40.3845 26.5547C36.5818 25.4884 40.0203 23.7121 41.9157 25.1424C42.1587 25.3827 42.6195 24.031 42.404 23.9673C38.7952 21.2501 34.3046 26.7579 39.6541 27.8868C41.3626 28.0874 41.8277 29.7377 39.9801 29.8766C37.9021 30.038 37.4313 27.9634 36.9463 30.0771L36.9466 30.0774Z" fill="white"/>
    <path d="M55.3832 25.7015C53.6429 20.8261 46.9733 24.2878 48.8597 28.7519C50.5964 33.5862 57.2819 30.1914 55.3832 25.7015Z" fill="white"/>
    <path d="M50.2956 27.2262C49.8982 23.846 54.3513 23.8523 53.9619 27.2262C54.3497 30.6147 49.8989 30.6233 50.2956 27.2262Z" fill="#00A1E0"/>
    <path d="M67.0537 29.6097C63.9671 30.4506 62.1514 28.2358 63.742 25.3518C64.404 24.2464 66.1128 24.8825 66.9863 24.7764C68.4431 22.491 63.2072 23.1974 62.5043 24.4609C60.5419 26.8815 61.7185 31.3688 65.3326 31.0993C66.6453 30.9614 67.9358 31.1513 67.054 29.6097H67.0537Z" fill="white"/>
    <path d="M74.3251 25.4337C67.9986 17.242 64.0142 34.5743 74.1545 30.623C74.3756 30.5514 73.8803 29.6541 73.8796 29.5139C72.4693 29.7018 69.4916 30.4592 69.5178 27.6226C69.6622 27.5069 74.4619 27.855 74.4679 27.5026C74.4729 27.4506 74.6339 26.5155 74.3251 25.4333V25.4337Z" fill="white"/>
    <path d="M69.5403 26.4383C69.7514 23.9925 72.8875 23.9514 72.9715 26.4383H69.5403Z" fill="#00A1E0"/>
    <path d="M35.7956 25.4337C35.2591 23.4449 32.9573 22.9083 31.3016 23.6441C26.2214 26.671 31.5968 33.7115 35.6661 30.3933C35.6658 30.3933 35.3524 29.5142 35.3524 29.5142C33.942 29.7012 30.9637 30.4609 30.9896 27.623C31.1336 27.5073 35.9337 27.8553 35.9397 27.503C35.9447 27.4509 36.1053 26.5159 35.7956 25.4337Z" fill="white"/>
    <path d="M34.4429 26.4387H31.0117C31.0429 24.0751 34.5203 24.0187 34.4429 26.4387Z" fill="#00A1E0"/>
    <path d="M19.0611 24.1795C19.1458 24.2626 19.3516 25.2961 19.5594 25.1712C22.5773 23.3551 24.636 26.5212 22.5272 26.2086C15.1979 26.321 19.1653 33.4854 24.8542 30.5046C25.2702 26.0045 24.7469 21.0475 19.0611 24.1795Z" fill="white"/>
    <path d="M20.613 29.5836C18.9806 27.7987 21.9858 27.0293 23.3218 27.5086C23.3228 27.5086 23.3198 29.6943 23.3228 29.6919C22.8158 29.8471 20.9928 29.9995 20.613 29.5832V29.5836Z" fill="#00A1E0"/>
    <path d="M61.3293 23.7336C60.7177 23.025 58.9143 23.5009 58.3971 24.2209V23.6368C58.4674 23.3922 56.8134 23.4071 56.8871 23.6368C57.0219 23.7833 56.6228 30.9756 57.0332 30.9468C60.5916 31.9126 56.014 24.2189 60.7924 24.8715C61.1048 24.8082 61.2031 23.8997 61.3289 23.7336" fill="white"/>
    <path d="M49.4653 20.4135C47.1984 19.6998 45.4398 21.1215 45.2728 23.4837C45.1131 23.5633 44.0513 23.321 44.0195 23.623C43.7054 24.9766 43.7874 24.7904 45.06 24.7774C44.226 26.4493 44.9288 34.0095 41.7061 32.9495C41.4372 32.865 41.2861 33.8613 41.1746 34.0022C41.5202 34.6485 42.984 34.3691 43.5746 34.2067C46.1602 33.0821 45.8368 27.0555 46.5961 24.7774C46.5958 24.7774 48.1801 24.7774 48.1801 24.7774C48.4228 24.8503 48.4573 23.7473 48.5207 23.6385C48.6296 23.3091 46.9401 23.557 46.8252 23.4837C46.8335 23.4496 46.9032 22.909 47.0795 22.4002C47.3996 21.3057 48.5257 21.7032 49.1867 21.5895C49.1552 21.4996 49.7631 20.4221 49.4656 20.4135" fill="white"/>
    <path d="M27.9737 30.801C28.052 31.0549 26.3409 31.0208 26.4226 30.801C26.5527 30.6558 26.1696 20.3856 26.5594 20.4055C26.5594 20.4052 27.8356 20.4052 27.8356 20.4052C28.229 20.3843 27.8429 30.6558 27.974 30.801H27.9737Z" fill="white"/>
  </g>
  <defs>
    <clipPath id="clip0_6290_28488">
      <rect width="83" height="58" fill="white"/>
    </clipPath>
  </defs>
</svg>`;

                this.init();
            }



            setupPostProcessing() {
                const renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
                    minFilter: THREE.LinearFilter,
                    magFilter: THREE.LinearFilter,
                    format: THREE.RGBAFormat,
                    encoding: THREE.sRGBEncoding
                });

                this.composer = new THREE.EffectComposer(this.renderer, renderTarget);
                
                // Render pass
                const renderPass = new THREE.RenderPass(this.scene, this.camera);
                this.composer.addPass(renderPass);

                // Bloom pass
                this.bloomPass = new THREE.UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    this.bloomIntensity,
                    this.bloomRadius,
                    this.bloomThreshold
                );
                this.composer.addPass(this.bloomPass);

                // Copy pass to screen
                const copyPass = new THREE.ShaderPass(THREE.CopyShader);
                copyPass.renderToScreen = true;
                this.composer.addPass(copyPass);
            }



            init() {
                this.setupControls();
                this.setupFileInput();
                this.createBackgroundStarfield();
                this.loadBothSVGs();
                this.setupCamera();
                this.animate();
                this.handleResize();
            }

            setupCameraControls() {
                this.container.addEventListener('mousemove', (event) => {
                    this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                });

                this.container.addEventListener('wheel', (event) => {
                    event.preventDefault();
                    const zoomSpeed = 0.1;
                    this.camera.fov += event.deltaY * zoomSpeed;
                    this.camera.fov = Math.max(10, Math.min(120, this.camera.fov));
                    this.camera.updateProjectionMatrix();
                });

                // Touch controls for mobile
                let touchStartX = 0, touchStartY = 0;
                this.container.addEventListener('touchstart', (event) => {
                    touchStartX = event.touches[0].clientX;
                    touchStartY = event.touches[0].clientY;
                });

                this.container.addEventListener('touchmove', (event) => {
                    event.preventDefault();
                    const touchX = event.touches[0].clientX;
                    const touchY = event.touches[0].clientY;
                    this.mouse.x = (touchX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(touchY / window.innerHeight) * 2 + 1;
                });
            }

            setupControls() {
                const controls = ['constellationSize', 'animationSpeed', 'pathDensity', 'outlineOpacity', 'lineThickness', 'bloomIntensity', 'bloomRadius', 'bloomThreshold', 'backgroundOpacity'];
                
                controls.forEach(controlName => {
                    const element = document.getElementById(controlName);
                    const valueElement = document.getElementById(controlName + 'Value');
                    
                    if (element && valueElement) {
                        element.addEventListener('input', (e) => {
                            const value = parseFloat(e.target.value);
                            this[controlName] = value;
                            valueElement.textContent = value;
                            
                            if (controlName === 'pathDensity') {
                                this.extractPointsFromPaths(1);
                                this.extractPointsFromPaths(2);
                            } else if (controlName === 'constellationSize') {
                                this.updateConstellationScale();
                            } else if (controlName === 'outlineOpacity') {
                                this.updateOutlineMaterials();
                            } else if (controlName === 'lineThickness') {
                                this.extractPointsFromPaths(1); // Recreate with new thickness
                                this.extractPointsFromPaths(2);
                            } else if (controlName === 'bloomIntensity' || controlName === 'bloomRadius' || controlName === 'bloomThreshold') {
                                this.updateBloomSettings();
                            } else if (controlName === 'backgroundOpacity') {
                                this.updateBackgroundOpacity();
                            }
                        });
                        
                        valueElement.textContent = element.value;
                    }
                });
            }

            setupFileInput() {
                const fileInput = document.getElementById('svgFile');
                if (fileInput) {
                    fileInput.addEventListener('change', (e) => {
                        const file = e.target.files[0];
                        if (file && file.type === 'image/svg+xml') {
                            const reader = new FileReader();
                            reader.onload = (e) => {
                                this.loadSVG(e.target.result, 1);
                            };
                            reader.readAsText(file);
                        }
                    });
                }
            }

            createBackgroundStarfield() {
                const starCount = 1500;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(starCount * 3);
                const sizes = new Float32Array(starCount);
                const colors = new Float32Array(starCount * 3);

                for (let i = 0; i < starCount * 3; i += 3) {
                    // Create stars in a sphere around the viewer - much closer and more visible
                    const radius = 150 + Math.random() * 300;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);

                    positions[i] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i + 2] = radius * Math.cos(phi);

                    sizes[i / 3] = 2.0 + Math.random() * 6.0; // Much larger stars

                    // Brighter star colors
                    const colorChoice = Math.random();
                    if (colorChoice < 0.6) {
                        // Bright white stars (60%)
                        colors[i] = 1.0;
                        colors[i + 1] = 1.0;
                        colors[i + 2] = 1.0;
                    } else if (colorChoice < 0.8) {
                        // Bright blue stars (20%)
                        colors[i] = 0.8;
                        colors[i + 1] = 0.9;
                        colors[i + 2] = 1.0;
                    } else if (colorChoice < 0.95) {
                        // Bright yellow stars (15%)
                        colors[i] = 1.0;
                        colors[i + 1] = 1.0;
                        colors[i + 2] = 0.9;
                    } else {
                        // Bright red stars (5%)
                        colors[i] = 1.0;
                        colors[i + 1] = 0.8;
                        colors[i + 2] = 0.8;
                    }
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        opacity: { value: 1.0 } // Full opacity
                    },
                    vertexShader: `
                        attribute float size;
                        attribute vec3 color;
                        uniform float time;
                        varying float vAlpha;
                        varying vec3 vColor;
                        
                        void main() {
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            
                            // Create slower, more subtle twinkling effect
                            float twinkle = sin(time * 0.5 + position.x * 0.01 + position.y * 0.015) * 0.3 + 0.7;
                            twinkle *= sin(time * 0.3 + position.z * 0.01) * 0.2 + 0.8;
                            vAlpha = twinkle;
                            vColor = color;
                            
                            gl_PointSize = size * (500.0 / -mvPosition.z) * twinkle; // Much larger point size
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        uniform float opacity;
                        varying float vAlpha;
                        varying vec3 vColor;
                        
                        void main() {
                            vec2 center = vec2(0.5, 0.5);
                            float dist = distance(gl_PointCoord, center);
                            
                            if (dist > 0.5) discard;
                            
                            float alpha = 1.0 - (dist * 2.0);
                            alpha = alpha * alpha * vAlpha * opacity;
                            
                            // Make stars brighter
                            vec3 brightColor = vColor * 1.5;
                            gl_FragColor = vec4(brightColor, alpha);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });

                const stars = new THREE.Points(geometry, material);
                this.backgroundGroup.add(stars);
                this.backgroundStarMaterial = material;
            }

            loadBothSVGs() {
                this.loadSVG(this.defaultSVG, 1);
                this.loadSVG(this.geometricSVG, 2);
            }

            loadSVG(svgString, constellationNumber = 1) {
                try {
                    const parser = new DOMParser();
                    const svgDoc = parser.parseFromString(svgString, 'image/svg+xml');
                    const svgElement = svgDoc.querySelector('svg');
                    
                    if (svgElement) {
                        const viewBox = svgElement.getAttribute('viewBox');
                        if (viewBox) {
                            const [x, y, width, height] = viewBox.split(' ').map(Number);
                            if (constellationNumber === 1) {
                                this.svgBounds = { x, y, width, height };
                            } else {
                                this.svgBounds2 = { x, y, width, height };
                            }
                        } else {
                            if (constellationNumber === 1) {
                                this.svgBounds = { x: 0, y: 0, width: 100, height: 100 };
                            } else {
                                this.svgBounds2 = { x: 0, y: 0, width: 100, height: 100 };
                            }
                        }
                        
                        const paths = Array.from(svgElement.querySelectorAll('path')).map(path => ({
                            d: path.getAttribute('d')
                        }));
                        
                        if (constellationNumber === 1) {
                            this.svgPaths = paths;
                        } else {
                            this.svgPaths2 = paths;
                        }
                        
                        this.extractPointsFromPaths(constellationNumber);
                    }
                } catch (error) {
                    console.error('Error loading SVG:', error);
                }
            }

            extractPointsFromPaths(constellationNumber = 1) {
                const group = constellationNumber === 1 ? this.constellationGroup : this.constellationGroup2;
                const outlines = constellationNumber === 1 ? this.constellationOutlines : this.constellationOutlines2;
                const stars = constellationNumber === 1 ? this.constellationStars : this.constellationStars2;
                const paths = constellationNumber === 1 ? this.svgPaths : this.svgPaths2;
                const bounds = constellationNumber === 1 ? this.svgBounds : this.svgBounds2;

                // Clear existing constellation outlines and stars
                outlines.forEach(outline => {
                    group.remove(outline);
                });
                if (constellationNumber === 1) {
                    this.constellationOutlines = [];
                } else {
                    this.constellationOutlines2 = [];
                }

                stars.forEach(star => {
                    group.remove(star);
                });
                if (constellationNumber === 1) {
                    this.constellationStars = [];
                } else {
                    this.constellationStars2 = [];
                }

                if (!paths.length || !bounds) return;

                const scale = 4; // Scale for 3D space
                const offsetX = constellationNumber === 1 ? 40 : -40; // Top right vs bottom left - much more horizontal spacing
                const offsetY = constellationNumber === 1 ? 10 : -10; // Reduced vertical spacing - logos closer together

                // Create constellation outlines
                paths.forEach(pathData => {
                    if (pathData.d) {
                        const outline = this.createConstellationOutline(pathData.d, scale, bounds, offsetX, offsetY);
                        if (outline) {
                            if (constellationNumber === 1) {
                                this.constellationOutlines.push(outline);
                            } else {
                                this.constellationOutlines2.push(outline);
                            }
                            group.add(outline);
                        }
                    }
                });

                // Create random stars along the paths
                paths.forEach(pathData => {
                    if (pathData.d) {
                        const starPoints = this.generateRandomStarPoints(pathData.d, scale, bounds, offsetX, offsetY);
                        starPoints.forEach(point => {
                            const star = this.createConstellationStar(point);
                            if (constellationNumber === 1) {
                                this.constellationStars.push(star);
                            } else {
                                this.constellationStars2.push(star);
                            }
                            group.add(star);
                        });
                    }
                });

                this.updatePointInfo();
            }





            updateConstellationScale() {
                this.constellationGroup.scale.setScalar(this.constellationSize);
                this.constellationGroup2.scale.setScalar(this.constellationSize);
            }

            generateRandomStarPoints(pathString, scale, bounds, offsetX = 0, offsetY = 0) {
                const points = [];
                
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '1000');
                svg.setAttribute('height', '1000');
                svg.setAttribute('viewBox', `${bounds.x} ${bounds.y} ${bounds.width} ${bounds.height}`);
                
                const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                pathElement.setAttribute('d', pathString);
                pathElement.setAttribute('stroke', 'black');
                pathElement.setAttribute('stroke-width', '1');
                pathElement.setAttribute('fill', 'none');
                
                svg.appendChild(pathElement);
                document.body.appendChild(svg);
                
                try {
                    const totalLength = pathElement.getTotalLength();
                    const numStars = Math.max(3, Math.min(15, Math.floor(totalLength / 20))); // Random number of stars based on path length
                    
                    for (let i = 0; i < numStars; i++) {
                        const randomDistance = Math.random() * totalLength;
                        const point = pathElement.getPointAtLength(randomDistance);
                        
                        if (point) {
                            // Convert 2D SVG coordinates to 3D positions with offset
                            const x = (point.x - bounds.x - bounds.width / 2) * scale / 10 + offsetX;
                            const y = -(point.y - bounds.y - bounds.height / 2) * scale / 10 + offsetY;
                            const z = (Math.random() - 0.5) * 2; // Small depth variation
                            
                            points.push({ 
                                x, 
                                y, 
                                z, 
                                twinklePhase: Math.random() * Math.PI * 2,
                                size: 0.5 + Math.random() * 1.5 // Random star size
                            });
                        }
                    }
                } catch (error) {
                    console.warn('Could not generate star points:', error);
                } finally {
                    document.body.removeChild(svg);
                }

                return points;
            }

            createConstellationStar(point) {
                const geometry = new THREE.SphereGeometry(point.size * 0.1, 8, 8);
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        twinklePhase: { value: point.twinklePhase }
                    },
                    vertexShader: `
                        varying vec3 vPosition;
                        varying vec3 vNormal;
                        
                        void main() {
                            vPosition = position;
                            vNormal = normal;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform float twinklePhase;
                        varying vec3 vPosition;
                        varying vec3 vNormal;
                        
                        void main() {
                            float twinkle = sin(time * 2.0 + twinklePhase) * 0.3 + 0.7;
                            float intensity = twinkle;
                            
                            // Create bright emission for bloom effect
                            vec3 color = vec3(1.0, 1.0, 1.0) * intensity * 2.0;
                            gl_FragColor = vec4(color, 1.0);
                        }
                    `,
                    transparent: true
                });

                const star = new THREE.Mesh(geometry, material);
                star.position.set(point.x, point.y, point.z);

                return star;
            }

            createConstellationOutline(pathString, scale, bounds, offsetX = 0, offsetY = 0) {
                const points = [];
                
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '1000');
                svg.setAttribute('height', '1000');
                svg.setAttribute('viewBox', `${bounds.x} ${bounds.y} ${bounds.width} ${bounds.height}`);
                
                const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                pathElement.setAttribute('d', pathString);
                pathElement.setAttribute('stroke', 'black');
                pathElement.setAttribute('stroke-width', '1');
                pathElement.setAttribute('fill', 'none');
                
                svg.appendChild(pathElement);
                document.body.appendChild(svg);
                
                try {
                    const totalLength = pathElement.getTotalLength();
                    const segments = Math.max(100, Math.floor(totalLength / 0.2)); // Even more segments for ultra-smooth curves

                    for (let i = 0; i < segments; i++) {
                        const distance = (i / Math.max(1, segments - 1)) * totalLength;
                        const point = pathElement.getPointAtLength(distance);
                        
                        if (point) {
                            // Convert 2D SVG coordinates to 3D positions with offset
                            const x = (point.x - bounds.x - bounds.width / 2) * scale / 10 + offsetX;
                            const y = -(point.y - bounds.y - bounds.height / 2) * scale / 10 + offsetY;
                            const z = 0; // Keep outline flat
                            
                            points.push(new THREE.Vector3(x, y, z));
                        }
                    }
                } catch (error) {
                    console.warn('Could not create outline:', error);
                    return null;
                } finally {
                    document.body.removeChild(svg);
                }

                if (points.length < 2) return null;

                // Create curve from points
                const curve = new THREE.CatmullRomCurve3(points);
                
                // Create tube geometry for thick lines
                const tubeSegments = Math.max(400, points.length * 8); // Ultra-smooth tube segments
                const radius = this.lineThickness;
                const radialSegments = 16; // Ultra-smooth radial segments
                const closed = false;
                
                const geometry = new THREE.TubeGeometry(curve, tubeSegments, radius, radialSegments, closed);

                // Create glowing tube material
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        opacity: { value: this.outlineOpacity },
                        dashSize: { value: 5.0 },
                        gapSize: { value: 0.9 }
                    },
                    vertexShader: `
                        uniform float time;
                        varying vec3 vPosition;
                        varying vec3 vNormal;
                        varying vec2 vUv;
                        
                        void main() {
                            vPosition = position;
                            vNormal = normalize(normalMatrix * normal);
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform float opacity;
                        uniform float dashSize;
                        uniform float gapSize;
                        varying vec3 vPosition;
                        varying vec3 vNormal;
                        varying vec2 vUv;
                        
                        void main() {
                            // Create animated dashed effect along the tube
                            float totalSize = dashSize + gapSize;
                            float animatedOffset = time * 0.3;
                            float pattern = mod(vUv.x * 20.0 + animatedOffset, totalSize);
                            float dashAlpha = smoothstep(gapSize - 0.2, gapSize, pattern) * 
                                            (1.0 - smoothstep(dashSize, dashSize + 0.2, pattern));
                            
                            // Add fresnel glow effect
                            vec3 viewDirection = normalize(cameraPosition - vPosition);
                            float fresnel = 1.0 - abs(dot(vNormal, viewDirection));
                            fresnel = pow(fresnel, 2.0);
                            
                            // Combine effects
                            float finalAlpha = dashAlpha * opacity * (0.4 + fresnel * 0.6);
                            
                            // Pure white glow
                            vec3 glowColor = vec3(1.0, 1.0, 1.0);
                            gl_FragColor = vec4(glowColor, finalAlpha);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide
                });

                const tube = new THREE.Mesh(geometry, material);
                return tube;
            }

            updateOutlineMaterials() {
                this.constellationOutlines.forEach(outline => {
                    if (outline.material && outline.material.uniforms) {
                        outline.material.uniforms.opacity.value = this.outlineOpacity;
                    }
                });
                this.constellationOutlines2.forEach(outline => {
                    if (outline.material && outline.material.uniforms) {
                        outline.material.uniforms.opacity.value = this.outlineOpacity;
                    }
                });
            }



            updatePointInfo() {
                const pointInfoElement = document.getElementById('pointInfo');
                if (pointInfoElement) {
                    const totalOutlines = this.constellationOutlines.length + this.constellationOutlines2.length;
                    const totalStars = this.constellationStars.length + this.constellationStars2.length;
                    pointInfoElement.textContent = `Outlines: ${totalOutlines} | Stars: ${totalStars}`;
                }
            }

            updateBloomSettings() {
                if (this.bloomPass) {
                    this.bloomPass.strength = this.bloomIntensity;
                    this.bloomPass.radius = this.bloomRadius;
                    this.bloomPass.threshold = this.bloomThreshold;
                }
            }



            updateBackgroundOpacity() {
                if (this.backgroundStarMaterial) {
                    this.backgroundStarMaterial.uniforms.opacity.value = this.backgroundOpacity;
                }
            }



            setupCamera() {
                this.camera.position.z = 30;
                this.camera.lookAt(0, 0, 0);
            }

            handleResize() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    
                    if (this.composer) {
                        this.composer.setSize(window.innerWidth, window.innerHeight);
                    }
                });
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                this.animationOffset += this.animationSpeed * 0.01;

                // Smooth camera movement based on mouse
                const dampening = 0.02;
                this.targetRotation.x = this.mouse.y * 0.3;
                this.targetRotation.y = this.mouse.x * 0.3;
                
                this.currentRotation.x += (this.targetRotation.x - this.currentRotation.x) * dampening;
                this.currentRotation.y += (this.targetRotation.y - this.currentRotation.y) * dampening;

                // Apply rotation to constellation groups
                this.constellationGroup.rotation.x = this.currentRotation.x;
                this.constellationGroup.rotation.y = this.currentRotation.y;
                this.constellationGroup2.rotation.x = this.currentRotation.x;
                this.constellationGroup2.rotation.y = this.currentRotation.y;

                // Gentle background rotation - much slower
                this.backgroundGroup.rotation.y += 0.0001;

                // Update shader uniforms
                if (this.backgroundStarMaterial) {
                    this.backgroundStarMaterial.uniforms.time.value = this.animationOffset * 10;
                }

                this.constellationOutlines.forEach(outline => {
                    if (outline.material && outline.material.uniforms) {
                        outline.material.uniforms.time.value = this.animationOffset * 10;
                    }
                });

                this.constellationStars.forEach(star => {
                    if (star.material && star.material.uniforms) {
                        star.material.uniforms.time.value = this.animationOffset * 10;
                    }
                });

                this.constellationOutlines2.forEach(outline => {
                    if (outline.material && outline.material.uniforms) {
                        outline.material.uniforms.time.value = this.animationOffset * 10;
                    }
                });

                this.constellationStars2.forEach(star => {
                    if (star.material && star.material.uniforms) {
                        star.material.uniforms.time.value = this.animationOffset * 10;
                    }
                });



                this.composer.render();
            }
        }

        function loadSVGFromText() {
            if (nightSkyInstance) {
                const svgTextElement = document.getElementById('svgText');
                if (svgTextElement) {
                    const svgText = svgTextElement.value.trim();
                    if (svgText) {
                        nightSkyInstance.loadSVG(svgText, 1);
                    }
                }
            }
        }

        function resetToDefault() {
            if (nightSkyInstance) {
                nightSkyInstance.currentShape = 0;
                nightSkyInstance.loadBothSVGs();
                const svgTextElement = document.getElementById('svgText');
                const svgFileElement = document.getElementById('svgFile');
                if (svgTextElement) svgTextElement.value = '';
                if (svgFileElement) svgFileElement.value = '';
            }
        }

        function toggleShape() {
            if (nightSkyInstance) {
                nightSkyInstance.currentShape = nightSkyInstance.currentShape === 0 ? 1 : 0;
                const newSVG = nightSkyInstance.currentShape === 0 ? 
                    nightSkyInstance.defaultSVG : nightSkyInstance.geometricSVG;
                nightSkyInstance.loadSVG(newSVG);
            }
        }

        function toggleControls() {
            const controls = document.querySelector('.controls');
            if (controls) {
                controls.style.display = controls.style.display === 'none' ? 'block' : 'none';
            }
        }



        // Initialize the night sky
        nightSkyInstance = new NightSkyConstellations();
    </script>
</body>
</html>