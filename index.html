<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Night Sky Constellation Map</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #080E1C;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            color: white;
        }

        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 20px;
            backdrop-filter: blur(10px);
            z-index: 100;
            display: none; /* Hide controls by default */
        }

        .controls h1 {
            font-size: 16px;
            font-weight: normal;
            margin-bottom: 20px;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: #fff;
            text-align: center;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
            color: #ccc;
        }

        .slider {
            width: 100%;
            height: 2px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            border-radius: 1px;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .value {
            font-size: 9px;
            color: #999;
            margin-top: 3px;
        }

        .button {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            font-family: inherit;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            margin-top: 5px;
            transition: all 0.3s ease;
        }

        .button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .textarea {
            width: 100%;
            height: 60px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            color: white;
            font-family: inherit;
            font-size: 9px;
            resize: vertical;
        }

        .textarea::placeholder {
            color: #999;
        }

        .file-input {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            color: white;
            font-family: inherit;
            font-size: 10px;
        }

        .info {
            font-size: 9px;
            color: #999;
            margin-top: 8px;
            text-align: center;
        }

        .instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 4px;
            font-size: 10px;
            color: #ccc;
            max-width: 300px;
        }

        .controls-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 101;
            transition: all 0.3s ease;
        }

        .controls-toggle:hover {
            background: rgba(0, 0, 0, 0.8);
            border-color: rgba(255, 255, 255, 0.5);
        }

        #threejs-container {
            width: 100%;
            height: 100%;
        }

        .svg-section {
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            padding-top: 15px;
            margin-top: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="threejs-container"></div>
        
        <button class="controls-toggle" onclick="toggleControls()">⚙️</button>
        
        <div class="controls">
            <h1>Night Sky</h1>
            
            <div class="control-group">
                <label for="constellationSize">Constellation Size</label>
                <input type="range" id="constellationSize" class="slider" min="0.1" max="1" value="0.5" step="0.1">
                <div class="value" id="constellationSizeValue">1.5</div>
            </div>



            <div class="control-group">
                <label for="animationSpeed">Animation Speed</label>
                <input type="range" id="animationSpeed" class="slider" min="0" max="2" value="0.5" step="0.1">
                <div class="value" id="animationSpeedValue">0.5</div>
            </div>


            <div class="control-group">
                <label for="outlineOpacity">Outline Opacity</label>
                <input type="range" id="outlineOpacity" class="slider" min="0.7" max="1" value="1" step="0.05">
                <div class="value" id="outlineOpacityValue">0.6</div>
            </div>

            <div class="control-group">
                <label for="lineThickness">Line Thickness</label>
                <input type="range" id="lineThickness" class="slider" min="0.02" max="1" value="0.05" step="0.01">
                <div class="value" id="lineThicknessValue">0.05</div>
            </div>

            <div class="control-group">
                <label for="bloomIntensity">Bloom Intensity</label>
                <input type="range" id="bloomIntensity" class="slider" min="0" max="3" value="1" step="0.1">
                <div class="value" id="bloomIntensityValue">1</div>
            </div>

            <div class="control-group">
                <label for="bloomRadius">Bloom Radius</label>
                <input type="range" id="bloomRadius" class="slider" min="0" max="1" value="0.5" step="0.01">
                <div class="value" id="bloomRadiusValue">0.5</div>
            </div>

            <div class="control-group">
                <label for="bloomThreshold">Bloom Threshold</label>
                <input type="range" id="bloomThreshold" class="slider" min="0" max="1" value="0.3" step="0.01">
                <div class="value" id="bloomThresholdValue">0.3</div>
            </div>

            <div class="control-group">
                <label for="backgroundOpacity">Background Stars</label>
                <input type="range" id="backgroundOpacity" class="slider" min="0" max="1" value="1" step="0.1">
                <div class="value" id="backgroundOpacityValue">1</div>
            </div>



            <div class="control-group">
                <button class="button" onclick="toggleShape()">Switch Constellation</button>
            </div>

            <div class="svg-section">
                <div class="control-group">
                    <label for="svgFile">Upload SVG</label>
                    <input type="file" id="svgFile" class="file-input" accept=".svg">
                </div>

                <div class="control-group">
                    <label for="svgText">Paste SVG Code</label>
                    <textarea id="svgText" class="textarea" placeholder="Paste SVG code..."></textarea>
                    <button class="button" onclick="loadSVGFromText()">Load SVG</button>
                </div>

                <button class="button" onclick="resetToDefault()">Reset Default</button>
                
                <div class="info" id="pointInfo">Stars: 0</div>
            </div>
        </div>

        <div class="instructions">
            <strong>Controls:</strong><br>
            • Mouse/Touch: Look around<br>
            • Scroll: Zoom in/out<br>
            • Upload SVG to create custom constellations
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script>
        let nightSkyInstance = null;

        class NightSkyConstellations {
            constructor() {
                this.container = document.getElementById('threejs-container');
                
                // Scene setup
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(105, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x080E1C);
                this.container.appendChild(this.renderer.domElement);

                // Camera controls
                this.setupCameraControls();

                // Parameters
                this.constellationSize = 1.5;
                this.animationSpeed = 0.5;
                this.pathDensity = 50;
                this.outlineOpacity = 0.6;
                this.lineThickness = 0.05;
                this.bloomIntensity = 1;
                this.bloomRadius = 0.5;
                this.bloomThreshold = 0.3;
                this.backgroundOpacity = 1;

                // Animation
                this.animationOffset = 0;
                this.mouse = { x: 0, y: 0 };
                this.targetRotation = { x: 0, y: 0 };
                this.currentRotation = { x: 0, y: 0 };

                // Constellation data
                this.constellationOutlines = [];
                this.constellationStars = [];
                this.svgPaths = [];
                this.svgBounds = null;
                this.constellationOutlines2 = [];
                this.constellationStars2 = [];
                this.svgPaths2 = [];
                this.svgBounds2 = null;
                this.currentShape = 0;
                this.isMorphing = false;

                // Groups
                this.constellationGroup = new THREE.Group();
                this.constellationGroup2 = new THREE.Group();
                this.backgroundGroup = new THREE.Group();
                this.scene.add(this.constellationGroup);
                this.scene.add(this.constellationGroup2);
                this.scene.add(this.backgroundGroup);

                // Post-processing setup
                this.setupPostProcessing();

                // Default SVGs
                this.defaultSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="58" height="58" viewBox="0 0 58 58" fill="none">
  <path d="M19.0195 0.579834H23.9883C24.3268 0.580029 24.624 0.806722 24.7139 1.13354V1.13452L27.2051 10.4158V10.4167C27.3166 10.837 27.3307 11.2759 27.2471 11.7009L27.2051 11.8826L25.418 18.5437C24.5406 21.8097 22.039 24.3831 18.8154 25.3601L18.501 25.45L11.8281 27.2351C11.347 27.3622 10.8415 27.3624 10.3604 27.2351H10.3613L1.06445 24.7478L1.05859 24.7458L0.939453 24.7048C0.674993 24.5874 0.501953 24.325 0.501953 24.0281V19.0642C0.502161 18.6046 0.912605 18.2608 1.35352 18.324L1.44238 18.3416C5.70009 19.4826 10.5334 20.7755 13.5684 21.5867H13.5693C14.8827 21.9361 15.8256 20.3231 14.8545 19.3562H14.8535L0.719727 5.24585C0.578074 5.10108 0.500025 4.91134 0.5 4.71558C0.5 2.43324 2.35501 0.579834 4.64453 0.579834C4.84199 0.579898 5.03572 0.659811 5.17773 0.800537L19.3105 14.9119C20.2724 15.8722 21.8965 14.9451 21.541 13.6238L18.2939 1.52026V1.51929C18.1673 1.0489 18.5236 0.580108 19.0195 0.579834Z" stroke="#1A1A1A" stroke-miterlimit="10"/>
  <path d="M38.7817 0.5H33.813C33.4744 0.500195 33.1772 0.726888 33.0874 1.05371V1.05469L30.5962 10.3359V10.3369C30.4847 10.7572 30.4706 11.1961 30.5542 11.6211L30.5962 11.8027L32.3833 18.4639C33.2607 21.7298 35.7623 24.3033 38.9858 25.2803L39.3003 25.3701L45.9731 27.1553C46.4543 27.2824 46.9598 27.2826 47.4409 27.1553H47.4399L56.7368 24.668L56.7427 24.666L56.8618 24.625C57.1263 24.5076 57.2993 24.2451 57.2993 23.9482V18.9844C57.2991 18.5248 56.8887 18.181 56.4478 18.2441L56.3589 18.2617C52.1012 19.4028 47.2678 20.6957 44.2329 21.5068H44.2319C42.9186 21.8563 41.9757 20.2433 42.9468 19.2764H42.9478L57.0815 5.16602C57.2232 5.02125 57.3012 4.83151 57.3013 4.63574C57.3013 2.35341 55.4463 0.5 53.1567 0.5C52.9593 0.500065 52.7655 0.579977 52.6235 0.720703L38.4907 14.832C37.5289 15.7924 35.9048 14.8653 36.2603 13.5439L39.5073 1.44043V1.43945C39.6339 0.969069 39.2777 0.500274 38.7817 0.5Z" stroke="#1A1A1A" stroke-miterlimit="10"/>
  <path d="M38.7817 57.251H33.813C33.4744 57.2508 33.1772 57.0241 33.0874 56.6973V56.6963L30.5962 47.415V47.4141C30.4847 46.9938 30.4706 46.5549 30.5542 46.1299L30.5962 45.9482L32.3833 39.2871C33.2607 36.0212 35.7623 33.4477 38.9858 32.4707L39.3003 32.3809L45.9731 30.5957C46.4543 30.4686 46.9598 30.4684 47.4409 30.5957H47.4399L56.7368 33.083L56.7427 33.085L56.8618 33.126C57.1263 33.2434 57.2993 33.5058 57.2993 33.8027V38.7666C57.2991 39.2262 56.8887 39.57 56.4478 39.5068L56.3589 39.4893C52.1012 38.3482 47.2678 37.0553 44.2329 36.2441H44.2319C42.9186 35.8947 41.9757 37.5077 42.9468 38.4746H42.9478L57.0815 52.585C57.2232 52.7297 57.3012 52.9195 57.3013 53.1152C57.3013 55.3976 55.4463 57.251 53.1567 57.251C52.9593 57.2509 52.7655 57.171 52.6235 57.0303L38.4907 42.9189C37.5289 41.9586 35.9048 42.8857 36.2603 44.207L39.5073 56.3105V56.3115C39.6339 56.7819 39.2777 57.2507 38.7817 57.251Z" stroke="#1A1A1A" stroke-miterlimit="10"/>
  <path d="M19.0195 57.251H23.9883C24.3268 57.2508 24.624 57.0241 24.7139 56.6973V56.6963L27.2051 47.415V47.4141C27.3166 46.9938 27.3307 46.5549 27.2471 46.1299L27.2051 45.9482L25.418 39.2871C24.5406 36.0212 22.039 33.4477 18.8154 32.4707L18.501 32.3809L11.8281 30.5957C11.347 30.4686 10.8415 30.4684 10.3604 30.5957H10.3613L1.06445 33.083L1.05859 33.085L0.939453 33.126C0.674993 33.2434 0.501953 33.5058 0.501953 33.8027V38.7666C0.502161 39.2262 0.912605 39.57 1.35352 39.5068L1.44238 39.4893C5.70009 38.3482 10.5334 37.0553 13.5684 36.2441H13.5693C14.8827 35.8947 15.8256 37.5077 14.8545 38.4746H14.8535L0.719727 52.585C0.578074 52.7297 0.500025 52.9195 0.5 53.1152C0.5 55.3976 2.35501 57.251 4.64453 57.251C4.84199 57.2509 5.03572 57.171 5.17773 57.0303L19.3105 42.9189C20.2724 41.9586 21.8965 42.8857 21.541 44.207L18.2939 56.3105V56.3115C18.1673 56.7819 18.5236 57.2507 19.0195 57.251Z" stroke="#1A1A1A" stroke-miterlimit="10"/>
</svg>`;

                this.geometricSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="71" height="50" viewBox="0 0 71 50" fill="none">
  <path d="M18.5887 7.72406e-06C20.7109 -0.00224775 22.8048 0.489487 24.7059 1.43663C26.6071 2.38376 28.264 3.76054 29.5464 5.45891L29.7614 5.22287C32.0343 2.95501 35.1328 1.56113 38.5443 1.56113C43.241 1.56113 47.3103 4.18577 49.502 8.09541C51.447 7.22069 53.5542 6.76896 55.6854 6.76987C64.1384 6.76987 71 13.7247 71 22.3059C71 30.8875 64.1384 37.8414 55.6854 37.8414C54.6524 37.8414 53.6452 37.7366 52.659 37.5398C50.7414 40.9773 47.0758 43.3131 42.9012 43.3131C41.2016 43.3163 39.5239 42.9285 37.9967 42.1794C36.0528 46.772 31.5266 49.9995 26.2565 50C20.7513 50 16.0818 46.5091 14.2812 41.602C13.4799 41.7722 12.6631 41.8577 11.8441 41.8572C5.29602 41.8577 0 36.4512 0 29.8121C0 25.3511 2.38443 21.4665 5.92253 19.3673C5.17189 17.6279 4.78553 15.7521 4.78747 13.8564C4.78747 6.1939 10.9709 7.72406e-06 18.5887 7.72406e-06Z" fill="white"/>
</svg>`;

                this.init();
            }



            setupPostProcessing() {
                const renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
                    minFilter: THREE.LinearFilter,
                    magFilter: THREE.LinearFilter,
                    format: THREE.RGBAFormat,
                    encoding: THREE.sRGBEncoding
                });

                this.composer = new THREE.EffectComposer(this.renderer, renderTarget);
                
                // Render pass
                const renderPass = new THREE.RenderPass(this.scene, this.camera);
                this.composer.addPass(renderPass);

                // Bloom pass
                this.bloomPass = new THREE.UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    this.bloomIntensity,
                    this.bloomRadius,
                    this.bloomThreshold
                );
                this.composer.addPass(this.bloomPass);

                // Copy pass to screen
                const copyPass = new THREE.ShaderPass(THREE.CopyShader);
                copyPass.renderToScreen = true;
                this.composer.addPass(copyPass);
            }



            init() {
                this.setupControls();
                this.setupFileInput();
                this.createBackgroundStarfield();
                this.loadBothSVGs();
                this.setupCamera();
                this.animate();
                this.handleResize();
            }

            setupCameraControls() {
                this.container.addEventListener('mousemove', (event) => {
                    this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                });

                this.container.addEventListener('wheel', (event) => {
                    event.preventDefault();
                    const zoomSpeed = 0.1;
                    this.camera.fov += event.deltaY * zoomSpeed;
                    this.camera.fov = Math.max(10, Math.min(120, this.camera.fov));
                    this.camera.updateProjectionMatrix();
                });

                // Touch controls for mobile
                let touchStartX = 0, touchStartY = 0;
                this.container.addEventListener('touchstart', (event) => {
                    touchStartX = event.touches[0].clientX;
                    touchStartY = event.touches[0].clientY;
                });

                this.container.addEventListener('touchmove', (event) => {
                    event.preventDefault();
                    const touchX = event.touches[0].clientX;
                    const touchY = event.touches[0].clientY;
                    this.mouse.x = (touchX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(touchY / window.innerHeight) * 2 + 1;
                });
            }

            setupControls() {
                const controls = ['constellationSize', 'animationSpeed', 'pathDensity', 'outlineOpacity', 'lineThickness', 'bloomIntensity', 'bloomRadius', 'bloomThreshold', 'backgroundOpacity'];
                
                controls.forEach(controlName => {
                    const element = document.getElementById(controlName);
                    const valueElement = document.getElementById(controlName + 'Value');
                    
                    if (element && valueElement) {
                        element.addEventListener('input', (e) => {
                            const value = parseFloat(e.target.value);
                            this[controlName] = value;
                            valueElement.textContent = value;
                            
                            if (controlName === 'pathDensity') {
                                this.extractPointsFromPaths(1);
                                this.extractPointsFromPaths(2);
                            } else if (controlName === 'constellationSize') {
                                this.updateConstellationScale();
                            } else if (controlName === 'outlineOpacity') {
                                this.updateOutlineMaterials();
                            } else if (controlName === 'lineThickness') {
                                this.extractPointsFromPaths(1); // Recreate with new thickness
                                this.extractPointsFromPaths(2);
                            } else if (controlName === 'bloomIntensity' || controlName === 'bloomRadius' || controlName === 'bloomThreshold') {
                                this.updateBloomSettings();
                            } else if (controlName === 'backgroundOpacity') {
                                this.updateBackgroundOpacity();
                            }
                        });
                        
                        valueElement.textContent = element.value;
                    }
                });
            }

            setupFileInput() {
                const fileInput = document.getElementById('svgFile');
                if (fileInput) {
                    fileInput.addEventListener('change', (e) => {
                        const file = e.target.files[0];
                        if (file && file.type === 'image/svg+xml') {
                            const reader = new FileReader();
                            reader.onload = (e) => {
                                this.loadSVG(e.target.result, 1);
                            };
                            reader.readAsText(file);
                        }
                    });
                }
            }

            createBackgroundStarfield() {
                const starCount = 1000; // Reduced star count
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(starCount * 3);
                const sizes = new Float32Array(starCount);
                const colors = new Float32Array(starCount * 3);

                for (let i = 0; i < starCount * 3; i += 3) {
                    // Create stars in a sphere around the viewer - much closer and more visible
                    const radius = 150 + Math.random() * 300;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);

                    positions[i] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i + 2] = radius * Math.cos(phi);

                    sizes[i / 3] = 1.0 + Math.random() * 3.0; // Smaller stars

                    // Softer star colors
                    const colorChoice = Math.random();
                    if (colorChoice < 0.6) {
                        // Soft white stars (60%)
                        colors[i] = 0.6;
                        colors[i + 1] = 0.6;
                        colors[i + 2] = 0.6;
                    } else if (colorChoice < 0.8) {
                        // Soft blue stars (20%)
                        colors[i] = 0.4;
                        colors[i + 1] = 0.5;
                        colors[i + 2] = 0.6;
                    } else if (colorChoice < 0.95) {
                        // Soft yellow stars (15%)
                        colors[i] = 0.6;
                        colors[i + 1] = 0.6;
                        colors[i + 2] = 0.5;
                    } else {
                        // Soft red stars (5%)
                        colors[i] = 0.6;
                        colors[i + 1] = 0.4;
                        colors[i + 2] = 0.4;
                    }
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        opacity: { value: 1.0 } // Full opacity
                    },
                    vertexShader: `
                        attribute float size;
                        attribute vec3 color;
                        uniform float time;
                        varying float vAlpha;
                        varying vec3 vColor;
                        
                        void main() {
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            
                            // Create slower, more subtle twinkling effect
                            float twinkle = sin(time * 0.5 + position.x * 0.01 + position.y * 0.015) * 0.3 + 0.7;
                            twinkle *= sin(time * 0.3 + position.z * 0.01) * 0.2 + 0.8;
                            vAlpha = twinkle;
                            vColor = color;
                            
                            gl_PointSize = size * (500.0 / -mvPosition.z) * twinkle; // Much larger point size
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        uniform float opacity;
                        varying float vAlpha;
                        varying vec3 vColor;
                        
                        void main() {
                            vec2 center = vec2(0.5, 0.5);
                            float dist = distance(gl_PointCoord, center);
                            
                            if (dist > 0.5) discard;
                            
                            float alpha = 1.0 - (dist * 2.0);
                            alpha = alpha * alpha * vAlpha * opacity;
                            
                            // Softer star colors
                            vec3 softColor = vColor * 0.8;
                            gl_FragColor = vec4(softColor, alpha);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });

                const stars = new THREE.Points(geometry, material);
                this.backgroundGroup.add(stars);
                this.backgroundStarMaterial = material;
            }

            loadBothSVGs() {
                this.loadSVG(this.defaultSVG, 1);
                this.loadSVG(this.geometricSVG, 2);
            }

            loadSVG(svgString, constellationNumber = 1) {
                try {
                    const parser = new DOMParser();
                    const svgDoc = parser.parseFromString(svgString, 'image/svg+xml');
                    const svgElement = svgDoc.querySelector('svg');
                    
                    if (svgElement) {
                        const viewBox = svgElement.getAttribute('viewBox');
                        if (viewBox) {
                            const [x, y, width, height] = viewBox.split(' ').map(Number);
                            if (constellationNumber === 1) {
                                this.svgBounds = { x, y, width, height };
                            } else {
                                this.svgBounds2 = { x, y, width, height };
                            }
                        } else {
                            if (constellationNumber === 1) {
                                this.svgBounds = { x: 0, y: 0, width: 100, height: 100 };
                            } else {
                                this.svgBounds2 = { x: 0, y: 0, width: 100, height: 100 };
                            }
                        }
                        
                        const paths = Array.from(svgElement.querySelectorAll('path')).map(path => ({
                            d: path.getAttribute('d')
                        }));
                        
                        if (constellationNumber === 1) {
                            this.svgPaths = paths;
                        } else {
                            this.svgPaths2 = paths;
                        }
                        
                        this.extractPointsFromPaths(constellationNumber);
                    }
                } catch (error) {
                    console.error('Error loading SVG:', error);
                }
            }

            extractPointsFromPaths(constellationNumber = 1) {
                const group = constellationNumber === 1 ? this.constellationGroup : this.constellationGroup2;
                const outlines = constellationNumber === 1 ? this.constellationOutlines : this.constellationOutlines2;
                const stars = constellationNumber === 1 ? this.constellationStars : this.constellationStars2;
                const paths = constellationNumber === 1 ? this.svgPaths : this.svgPaths2;
                const bounds = constellationNumber === 1 ? this.svgBounds : this.svgBounds2;

                // Clear existing constellation outlines and stars
                outlines.forEach(outline => {
                    group.remove(outline);
                });
                if (constellationNumber === 1) {
                    this.constellationOutlines = [];
                } else {
                    this.constellationOutlines2 = [];
                }

                stars.forEach(star => {
                    group.remove(star);
                });
                if (constellationNumber === 1) {
                    this.constellationStars = [];
                } else {
                    this.constellationStars2 = [];
                }

                if (!paths.length || !bounds) return;

                const scale = 4; // Scale for 3D space
                const offsetX = constellationNumber === 1 ? 40 : -40; // Top right vs bottom left - much more horizontal spacing
                const offsetY = constellationNumber === 1 ? 10 : -10; // Reduced vertical spacing - logos closer together

                // Create constellation outlines
                paths.forEach(pathData => {
                    if (pathData.d) {
                        const outline = this.createConstellationOutline(pathData.d, scale, bounds, offsetX, offsetY);
                        if (outline) {
                            if (constellationNumber === 1) {
                                this.constellationOutlines.push(outline);
                            } else {
                                this.constellationOutlines2.push(outline);
                            }
                            group.add(outline);
                        }
                    }
                });

                // Create random stars along the paths
                paths.forEach(pathData => {
                    if (pathData.d) {
                        const starPoints = this.generateRandomStarPoints(pathData.d, scale, bounds, offsetX, offsetY);
                        starPoints.forEach(point => {
                            const star = this.createConstellationStar(point);
                            if (constellationNumber === 1) {
                                this.constellationStars.push(star);
                            } else {
                                this.constellationStars2.push(star);
                            }
                            group.add(star);
                        });
                    }
                });

                this.updatePointInfo();
            }





            updateConstellationScale() {
                this.constellationGroup.scale.setScalar(this.constellationSize);
                this.constellationGroup2.scale.setScalar(this.constellationSize);
            }

            generateRandomStarPoints(pathString, scale, bounds, offsetX = 0, offsetY = 0) {
                const points = [];
                
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '1000');
                svg.setAttribute('height', '1000');
                svg.setAttribute('viewBox', `${bounds.x} ${bounds.y} ${bounds.width} ${bounds.height}`);
                
                const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                pathElement.setAttribute('d', pathString);
                pathElement.setAttribute('stroke', 'black');
                pathElement.setAttribute('stroke-width', '1');
                pathElement.setAttribute('fill', 'none');
                
                svg.appendChild(pathElement);
                document.body.appendChild(svg);
                
                try {
                    const totalLength = pathElement.getTotalLength();
                    const numStars = Math.max(3, Math.min(15, Math.floor(totalLength / 20))); // Random number of stars based on path length
                    
                    // Use evenly distributed points along the path instead of random
                    for (let i = 0; i < numStars; i++) {
                        // Distribute stars evenly along the path with some randomness
                        const baseDistance = (i / (numStars - 1)) * totalLength;
                        const randomOffset = (Math.random() - 0.5) * (totalLength / numStars * 0.3); // Small random offset
                        const distance = Math.max(0, Math.min(totalLength, baseDistance + randomOffset));
                        
                        const point = pathElement.getPointAtLength(distance);
                        
                        if (point) {
                            // Convert 2D SVG coordinates to 3D positions with offset
                            const x = (point.x - bounds.x - bounds.width / 2) * scale / 10 + offsetX;
                            const y = -(point.y - bounds.y - bounds.height / 2) * scale / 10 + offsetY;
                            const z = 0; // Keep stars on the same plane as outlines for better alignment
                            
                            points.push({ 
                                x, 
                                y, 
                                z, 
                                twinklePhase: Math.random() * Math.PI * 2,
                                size: 0.5 + Math.random() * 1.5 // Random star size
                            });
                        }
                    }
                } catch (error) {
                    console.warn('Could not generate star points:', error);
                } finally {
                    document.body.removeChild(svg);
                }

                return points;
            }

            createConstellationStar(point) {
                const geometry = new THREE.SphereGeometry(point.size * 0.1, 8, 8);
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        twinklePhase: { value: point.twinklePhase }
                    },
                    vertexShader: `
                        varying vec3 vPosition;
                        varying vec3 vNormal;
                        
                        void main() {
                            vPosition = position;
                            vNormal = normal;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform float twinklePhase;
                        varying vec3 vPosition;
                        varying vec3 vNormal;
                        
                        void main() {
                            float twinkle = sin(time * 2.0 + twinklePhase) * 0.3 + 0.7;
                            float intensity = twinkle;
                            
                            // Create bright emission for bloom effect
                            vec3 color = vec3(1.0, 1.0, 1.0) * intensity * 2.0;
                            gl_FragColor = vec4(color, 1.0);
                        }
                    `,
                    transparent: true
                });

                const star = new THREE.Mesh(geometry, material);
                star.position.set(point.x, point.y, point.z);

                return star;
            }

            createConstellationOutline(pathString, scale, bounds, offsetX = 0, offsetY = 0) {
                const points = [];
                
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '1000');
                svg.setAttribute('height', '1000');
                svg.setAttribute('viewBox', `${bounds.x} ${bounds.y} ${bounds.width} ${bounds.height}`);
                
                const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                pathElement.setAttribute('d', pathString);
                pathElement.setAttribute('stroke', 'black');
                pathElement.setAttribute('stroke-width', '1');
                pathElement.setAttribute('fill', 'none');
                
                svg.appendChild(pathElement);
                document.body.appendChild(svg);
                
                try {
                    const totalLength = pathElement.getTotalLength();
                    const segments = Math.max(100, Math.floor(totalLength / 0.2)); // Even more segments for ultra-smooth curves

                    for (let i = 0; i < segments; i++) {
                        const distance = (i / Math.max(1, segments - 1)) * totalLength;
                        const point = pathElement.getPointAtLength(distance);
                        
                        if (point) {
                            // Convert 2D SVG coordinates to 3D positions with offset
                            const x = (point.x - bounds.x - bounds.width / 2) * scale / 10 + offsetX;
                            const y = -(point.y - bounds.y - bounds.height / 2) * scale / 10 + offsetY;
                            const z = 0; // Keep outline flat
                            
                            points.push(new THREE.Vector3(x, y, z));
                        }
                    }
                } catch (error) {
                    console.warn('Could not create outline:', error);
                    return null;
                } finally {
                    document.body.removeChild(svg);
                }

                if (points.length < 2) return null;

                // Create curve from points
                const curve = new THREE.CatmullRomCurve3(points);
                
                // Create tube geometry for thick lines
                const tubeSegments = Math.max(400, points.length * 8); // Ultra-smooth tube segments
                const radius = this.lineThickness;
                const radialSegments = 16; // Ultra-smooth radial segments
                const closed = false;
                
                const geometry = new THREE.TubeGeometry(curve, tubeSegments, radius, radialSegments, closed);

                // Create glowing tube material
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        opacity: { value: this.outlineOpacity },
                        dashSize: { value: 5.0 },
                        gapSize: { value: 0.9 }
                    },
                    vertexShader: `
                        uniform float time;
                        varying vec3 vPosition;
                        varying vec3 vNormal;
                        varying vec2 vUv;
                        
                        void main() {
                            vPosition = position;
                            vNormal = normalize(normalMatrix * normal);
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform float opacity;
                        uniform float dashSize;
                        uniform float gapSize;
                        varying vec3 vPosition;
                        varying vec3 vNormal;
                        varying vec2 vUv;
                        
                        void main() {
                            // Create animated dashed effect along the tube
                            float totalSize = dashSize + gapSize;
                            float animatedOffset = time * 0.3;
                            float pattern = mod(vUv.x * 20.0 + animatedOffset, totalSize);
                            float dashAlpha = smoothstep(gapSize - 0.2, gapSize, pattern) * 
                                            (1.0 - smoothstep(dashSize, dashSize + 0.2, pattern));
                            
                            // Add fresnel glow effect
                            vec3 viewDirection = normalize(cameraPosition - vPosition);
                            float fresnel = 1.0 - abs(dot(vNormal, viewDirection));
                            fresnel = pow(fresnel, 2.0);
                            
                            // Combine effects
                            float finalAlpha = dashAlpha * opacity * (0.4 + fresnel * 0.6);
                            
                            // Pure white glow
                            vec3 glowColor = vec3(1.0, 1.0, 1.0);
                            gl_FragColor = vec4(glowColor, finalAlpha);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide
                });

                const tube = new THREE.Mesh(geometry, material);
                return tube;
            }

            updateOutlineMaterials() {
                this.constellationOutlines.forEach(outline => {
                    if (outline.material && outline.material.uniforms) {
                        outline.material.uniforms.opacity.value = this.outlineOpacity;
                    }
                });
                this.constellationOutlines2.forEach(outline => {
                    if (outline.material && outline.material.uniforms) {
                        outline.material.uniforms.opacity.value = this.outlineOpacity;
                    }
                });
            }



            updatePointInfo() {
                const pointInfoElement = document.getElementById('pointInfo');
                if (pointInfoElement) {
                    const totalOutlines = this.constellationOutlines.length + this.constellationOutlines2.length;
                    const totalStars = this.constellationStars.length + this.constellationStars2.length;
                    pointInfoElement.textContent = `Outlines: ${totalOutlines} | Stars: ${totalStars}`;
                }
            }

            updateBloomSettings() {
                if (this.bloomPass) {
                    this.bloomPass.strength = this.bloomIntensity;
                    this.bloomPass.radius = this.bloomRadius;
                    this.bloomPass.threshold = this.bloomThreshold;
                }
            }



            updateBackgroundOpacity() {
                if (this.backgroundStarMaterial) {
                    this.backgroundStarMaterial.uniforms.opacity.value = this.backgroundOpacity;
                }
            }



            setupCamera() {
                this.camera.position.z = 30;
                this.camera.lookAt(0, 0, 0);
            }

            handleResize() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    
                    if (this.composer) {
                        this.composer.setSize(window.innerWidth, window.innerHeight);
                    }
                });
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                this.animationOffset += this.animationSpeed * 0.01;

                // Smooth camera movement based on mouse
                const dampening = 0.02;
                this.targetRotation.x = this.mouse.y * 0.3;
                this.targetRotation.y = this.mouse.x * 0.3;
                
                this.currentRotation.x += (this.targetRotation.x - this.currentRotation.x) * dampening;
                this.currentRotation.y += (this.targetRotation.y - this.currentRotation.y) * dampening;

                // Apply rotation to constellation groups
                this.constellationGroup.rotation.x = this.currentRotation.x;
                this.constellationGroup.rotation.y = this.currentRotation.y;
                this.constellationGroup2.rotation.x = this.currentRotation.x;
                this.constellationGroup2.rotation.y = this.currentRotation.y;

                // Gentle background rotation - much slower
                this.backgroundGroup.rotation.y += 0.0001;

                // Update shader uniforms
                if (this.backgroundStarMaterial) {
                    this.backgroundStarMaterial.uniforms.time.value = this.animationOffset * 10;
                }

                this.constellationOutlines.forEach(outline => {
                    if (outline.material && outline.material.uniforms) {
                        outline.material.uniforms.time.value = this.animationOffset * 10;
                    }
                });

                this.constellationStars.forEach(star => {
                    if (star.material && star.material.uniforms) {
                        star.material.uniforms.time.value = this.animationOffset * 10;
                    }
                });

                this.constellationOutlines2.forEach(outline => {
                    if (outline.material && outline.material.uniforms) {
                        outline.material.uniforms.time.value = this.animationOffset * 10;
                    }
                });

                this.constellationStars2.forEach(star => {
                    if (star.material && star.material.uniforms) {
                        star.material.uniforms.time.value = this.animationOffset * 10;
                    }
                });



                this.composer.render();
            }
        }

        function loadSVGFromText() {
            if (nightSkyInstance) {
                const svgTextElement = document.getElementById('svgText');
                if (svgTextElement) {
                    const svgText = svgTextElement.value.trim();
                    if (svgText) {
                        nightSkyInstance.loadSVG(svgText, 1);
                    }
                }
            }
        }

        function resetToDefault() {
            if (nightSkyInstance) {
                nightSkyInstance.currentShape = 0;
                nightSkyInstance.loadBothSVGs();
                const svgTextElement = document.getElementById('svgText');
                const svgFileElement = document.getElementById('svgFile');
                if (svgTextElement) svgTextElement.value = '';
                if (svgFileElement) svgFileElement.value = '';
            }
        }

        function toggleShape() {
            if (nightSkyInstance) {
                nightSkyInstance.currentShape = nightSkyInstance.currentShape === 0 ? 1 : 0;
                const newSVG = nightSkyInstance.currentShape === 0 ? 
                    nightSkyInstance.defaultSVG : nightSkyInstance.geometricSVG;
                nightSkyInstance.loadSVG(newSVG);
            }
        }

        function toggleControls() {
            const controls = document.querySelector('.controls');
            if (controls) {
                controls.style.display = controls.style.display === 'none' ? 'block' : 'none';
            }
        }



        // Initialize the night sky
        nightSkyInstance = new NightSkyConstellations();
    </script>
</body>
</html>